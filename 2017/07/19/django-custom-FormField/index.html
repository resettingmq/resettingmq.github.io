<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Django FormField 实现笔记 一 · Keep mind occupied</title><meta name="description" content="Django FormField 实现笔记 一 - resettingmq"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://resettingmq.github.io/atom.xml" title="Keep mind occupied"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Django FormField 实现笔记 一</h1><div class="post-info">2017年7月19日</div><div class="post-content"><p>在Web应用中对一对一关系的处理表单处理，有时需要同时将关系两端的form对象添加到同一个HTML表单中进行提交。</p>
<p>在Django中，一种常用的做法是在前端分辨渲染两个表单，然后在后端对提交数据分别进行处理并关联。</p>
<p>在这篇文章里，尝试一种新的思路：将Form包装进Field中，使其能够像普通Field一样定义在其它（外层）Form中，同时又能够提供Form操作的接口（例如渲染，验证，获取数据等）。</p>
<p>最终的效果示例可以在<a href="http://demo.resettingmq.top/formfield/" target="_blank" rel="external">这里</a>查看。</p>
<h1 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h1><ol>
<li><code>FormField</code>能够接受form_class参数以及initial参数，渲染这个Field的时候能够生成指定form；</li>
<li>from_class可以是ModelFrom，并能够根据instance参数指定的值初始化</li>
<li>能够接受model参数，通过fields参数指定生成ModelForms所包含的fields，并根据指定的instance初始化表单</li>
</ol>
<h1 id="FormField-数据"><a href="#FormField-数据" class="headerlink" title="FormField 数据"></a>FormField 数据</h1><h2 id="initial-数据"><a href="#initial-数据" class="headerlink" title="initial 数据"></a><code>initial</code> 数据</h2><p>对于内层Form中的Field，<code>initial</code>数据可以有三个来源：</p>
<ol>
<li>内层Form的Field在定义时指定的<code>initial</code>值；</li>
<li>FormField在定义时指定的<code>initial</code>值；</li>
<li>外层Form在实例化时指定的<code>initial</code>值</li>
</ol>
<p>这三种数据来源的优先级依次从低到高。</p>
<p>由于Django Field类型默认实现中只是简单的在Form initial和Field initial中选择，所以需要在<code>BoundFormField</code>重新实现<code>initial()</code>来修改获取<code>initial value</code>的逻辑（弃用了<code>Form.get_initial_for_field()</code>）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># in BoundFormField class definition</span></div><div class="line"></div><div class="line"><span class="meta">@property</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">initial</span><span class="params">(self)</span>:</span></div><div class="line">    value = copy.copy(self.field.initial) <span class="keyword">if</span> self.field.initial <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">else</span> &#123;&#125;</div><div class="line">    value.update(self.form.initial.get(self.name, &#123;&#125;))</div><div class="line">    </div><div class="line">    retur value</div></pre></td></tr></table></figure>
<p>这段代码实现了获取第2和第3种<code>initial</code>数据来源的优先级关系。对于第一种<code>initial</code>数据来源，只需要在内层Form实例化的时候，将该<code>initial</code>值作为<code>initial</code>参数传入，就能够实现覆盖内层Form的Field在定义时指定的<code>initial</code>值。</p>
<h2 id="POST-数据"><a href="#POST-数据" class="headerlink" title="POST 数据"></a>POST 数据</h2><p>在Django应用程序响应POST请求时，将POST数据作为data初始化参数来生成Form实例。</p>
<p>为了能够避免内层Form的Field与其它Field名称冲突，同时为了便于提取数据，内层Form的Field对应HTML标签的name属性为<code>&lt;prefix&gt;-&lt;inner_field_name&gt;</code> <del><code>&lt;form_prefix&gt;-&lt;formfield_name&gt;-&lt;inner_field_name&gt;</code></del> <del><code>&lt;formfield_name&gt;-&lt;inner_field_name&gt;</code></del> 的形式。</p>
<p>这个可以通过在内层Form实例化的时候指定<code>prefix</code>参数来实现。</p>
<blockquote>
<p>注意：为了能够正确的实现Form的多层嵌套，在POST数据中避免名称冲突，需要加上<code>&lt;form_prefix&gt;</code>。<br>同样，通过指定<code>form_prefix</code>，也能够避免同一嵌套层次中多个FormField的名称冲突。</p>
</blockquote>
<p><code>Widget.value_from_datadict(data, files, name)</code>方法提供从data中提取数据的接口。<br>为了符合POST数据的情况，这里约定data是一个没有嵌套的（多值）字典形式。</p>
<p>由于Django Form会处理Field的名字与prefix，在传入的data字典中取响应的值，忽略data字典中其它无关的值，所以<code>Widget.value_from.datadict(data, files, name)</code>方法仅需要简单的将整个(外层Form获取到的)data返回，不需要做数据的过滤与修剪。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">value_from_datadict</span><span class="params">(self, data, files, name)</span>:</span></div><div class="line">    <span class="keyword">return</span> data</div></pre></td></tr></table></figure>
<h1 id="提供Django-Form的接口"><a href="#提供Django-Form的接口" class="headerlink" title="提供Django Form的接口"></a>提供Django Form的接口</h1><p>虽然FormField是一个Django Field，但我们希望它能够提供一些Django Form的行为。例如：</p>
<ol>
<li>它的字符串表示形式应该是<code>Form.as_table()</code>的形式（保证在外层<code>Form.as_table()</code>的情况下，内层的FormField能够提供一致的输出）；<br> <em>但是在外层Form调用<code>as_p()/as_ul()</code>方法时似乎无解…</em></li>
<li>能够像Django Form一样通过字典的键访问FormField所具有的Field和BoundField；</li>
<li>对FormField进行验证的时候，会调用对内层Form的验证；</li>
</ol>
<p>Django Form能够通过类属性<code>base_fields</code>(或者<code>declared_fields</code>)访问Form定义时声明的Field实例，而如果外层Form没有实例化的情况下，应该不能够访问内嵌Form实例对象的属性的。<br>所以就要求FormField所包含的内层Form延迟实例化。</p>
<p>同时，还应该保证内层Form的实例化，必须发生在外层Form实例化之后，对内层Form实例属性进行访问之前。</p>
<p>所以，内层Form的实例化发生在第一次访问内层form的时候（例如对Form的验证，或者对Form的渲染），并且对这个生成的内层Form实例进行缓存，使得内层Form的验证和渲染是对同一个Form实例操作。</p>
<p>由于Django Form进行渲染或者取值是对<code>BoundField</code>对象进行；<br>并且Django对Form实例的迭代以及通过下标取值返回的也是BoundField对象，所以对内层Form实例的访问的逻辑应该在<code>BoundField</code>对象中实现。</p>
<p>所以考虑实现一个BoundField的子类，实现对内层Form实例访问的接口；同时在BoundField子类中增加一个<code>cached_property</code>，这样也能保证内层Form实例化的延迟。</p>
<p>当外层Form为unbound时（初始化参数data为None），生成的内层Form也应该为unbound，这样才能保证内层Form的initial值能够正常渲染（原因是<code>BoundField.value()</code>的默认实现会在bound的情况下使用<code>BoundField.data</code>渲染，而不是<code>BoundField.initial</code>，除非该<code>field.disabled==True</code>）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundFormField</span><span class="params">(BoundField)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, name)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.inner_form[name]</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> iter(self.inner_form)</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">data</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># 委托到inner form各field上取值</span></div><div class="line">        <span class="comment"># 对于多层嵌套的FormField实现了递归取值</span></div><div class="line">        <span class="comment"># 而不需要在POST数据中根据键来构建dict（需要实现递归逻辑）</span></div><div class="line">        <span class="keyword">return</span> &#123;name: self.inner_form[name].data <span class="keyword">for</span> name <span class="keyword">in</span> self.inner_form.fields&#125;</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_form</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> self._inner_form <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">for</span> field <span class="keyword">in</span> self._inner_form.fields.values():</div><div class="line">                field.disabled = self.field.disabled</div><div class="line">            <span class="keyword">return</span> self._inner_form</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> self._get_form()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_form</span><span class="params">(self, **kwargs)</span>:</span></div><div class="line">        kwargs[<span class="string">'initial'</span>] = self.initial</div><div class="line">        <span class="keyword">if</span> self.form.is_bound <span class="keyword">and</span> <span class="string">'data'</span> <span class="keyword">not</span> <span class="keyword">in</span> kwargs:</div><div class="line">            kwargs[<span class="string">'data'</span>] = self.form.data</div><div class="line">        inner_form = self.field.get_form(**kwargs)</div><div class="line">        self._inner_form = inner_form</div><div class="line">        <span class="keyword">return</span> inner_form</div><div class="line"></div><div class="line">    <span class="comment"># some other code ...</span></div></pre></td></tr></table></figure>
<h1 id="FormField上参数的处理"><a href="#FormField上参数的处理" class="headerlink" title="FormField上参数的处理"></a>FormField上参数的处理</h1><h2 id="1-required"><a href="#1-required" class="headerlink" title="1. required"></a>1. <code>required</code></h2><p>当在FormField上<code>required</code>为True时，内层Form的Field保持自身的<code>required</code>状态；为False时，整个内层Form可以为空，这个时候Form返回的值为<code>{}</code>(空dict)；</p>
<blockquote>
<p><del><em>注意：这里要求返回空dict。因为内层Form的生成依赖于<code>BoundFormField.data property</code>，如果这种情况下这个<code>property</code>返回<code>None</code>的话，则生成的内层From实例是<code>unbound</code>，再次渲染的时候会显示有<code>initial</code>的值</em></del></p>
<p><em>（因为对内层Form是否Bound的控制改在了<code>BoundFieldForm.inner_form property</code>中实现，所以这里不再有要求）</em></p>
</blockquote>
<p>Field的<code>use_required_attribute</code>参数只能控制表单渲染时不添加<code>required</code> HTML属性，不能改变Form在验证时对<code>required</code>的处理。</p>
<p>所以在FormField的<code>required</code>属性为False时，需要将内层Form所有的field的<code>required</code>属性设置为<code>False</code>。这在<code>FormField.gett_form()</code>中实现。</p>
<h2 id="2-disabled"><a href="#2-disabled" class="headerlink" title="2. disabled"></a>2. <code>disabled</code></h2><p>如果FormField上<code>disabled</code>为True时，内层Form所有Field为<code>disabled</code>状态，渲染以及验证的数据由<code>initial</code>的值决定；当为False时，内层Form各Field的<code>disabled</code>状态由自身决定。</p>
<p>同样，如果在<code>FormField.disabled == True</code>的情况下，应该将内层Form所有field的<code>disabled</code>属性设置为<code>True</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># in BaseFormField class definition</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_form</span><span class="params">(self, data=None, initial=None, **kwargs)</span>:</span></div><div class="line">    kwargs[<span class="string">'data'</span>] = data</div><div class="line">    kwargs[<span class="string">'initial'</span>] = initial</div><div class="line">    kwargs[<span class="string">'prefix'</span>] = self.prefix</div><div class="line"></div><div class="line">    form = self.form_class(**kwargs)</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.required:</div><div class="line">        <span class="keyword">for</span> field <span class="keyword">in</span> form.fields.values():</div><div class="line">            field.required = <span class="keyword">False</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> self.disabled:</div><div class="line">        <span class="keyword">for</span> field <span class="keyword">in</span> form.fields.values():</div><div class="line">            field.disabled = <span class="keyword">True</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> form</div></pre></td></tr></table></figure>
<h1 id="FormField验证"><a href="#FormField验证" class="headerlink" title="FormField验证"></a>FormField验证</h1><p>同样，FormField的验证也委托到内层Form的验证，在<code>FormField.clean()</code>中实现：</p>
<ol>
<li>如果内层Form验证通过，则返回内层Form的<code>cleaned_data</code>；</li>
<li>如果内层Form验证不通过，则根据内层Form的erros属性构造<code>ValidationError</code>，并抛出；</li>
</ol>
<p>因为验证的数据是dict（一般情况为<code>POST</code>数据），所以需要根据这个dict生成内层form实例，并将内层form实例验证生成的<code>cleaned_data</code>作为新的验证目标数据value返回。这部分逻辑在<code>FormField.to_python()</code>中实现。</p>
<p>有一个比较重要的问题是Django的验证过程中，没有将Field的name传入到<code>Field.clean()</code>中，所以没有办法为内层form实例指定正确的prefix。除非重写<code>Form._clean_fields()</code>，除此之外没有找到什么其它的办法。</p>
<p>所以退而求其次，在<code>FormField</code>初始化参数中加入prefix参数，手动指定。这样就能够在<code>to_python()</code>方法中生成正确的内层Form实例。</p>
<p><code>validate()</code>中实现<code>required</code>验证，可以直接利用默认实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># in BaseFormField class definition</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_python</span><span class="params">(self, value)</span>:</span></div><div class="line">    form = self.get_form(value)</div><div class="line">    <span class="keyword">if</span> form.is_valid():</div><div class="line">        <span class="keyword">return</span> form.cleaned_data</div><div class="line"></div><div class="line">    <span class="comment"># 将inner_form的errors转化为不带error_dict属性的ValidationError对象</span></div><div class="line">    new_error_list = []</div><div class="line">    <span class="keyword">for</span> name, error_list <span class="keyword">in</span> form.errors.as_data().items():</div><div class="line">        <span class="keyword">for</span> error <span class="keyword">in</span> error_list:</div><div class="line">            <span class="keyword">if</span> hasattr(error, <span class="string">'message'</span>):</div><div class="line">                error.message = <span class="string">'Field &#123;&#125; in FormField: &#123;&#125;'</span>.format(name, error.message)</div><div class="line">        new_error_list.extend(error_list)</div><div class="line">    <span class="keyword">raise</span> ValidationError(new_error_list, code=<span class="string">'FormFieldError'</span>)</div></pre></td></tr></table></figure>
<h1 id="HTML代码生成"><a href="#HTML代码生成" class="headerlink" title="HTML代码生成"></a>HTML代码生成</h1><p>在Django中，<code>Widget</code>主要负责根据表单项生成HTML以及从<code>POST</code>的数据中提取相关表单项的数据。</p>
<p>生成HTML代码主要在<code>Widget.render(name, value, attrs, form)</code>方法中实现。<br><code>Widget.render()</code>方法中的value参数包含了需要渲染的数据，在这个例子中，它是一个<code>form</code>的实例。</p>
<p>前面已经提到，将FormField字符串化（即在模板中直接输出FormField实例<em>（对应的UnboundField）</em>）的结果设计成调用内层Form的<code>as_table()</code>方法，所以只需要在<code>Widget.render()</code>方法中返回<code>value.as_table()</code>即可（下面会介绍一个小扩展，可以通过自定义template修改输出的FormField）。</p>
<h2 id="稍微扩展一下"><a href="#稍微扩展一下" class="headerlink" title="稍微扩展一下"></a>稍微扩展一下</h2><p>直接输出FormField内层Form的table形式，往往不是我们需要的，而通过内层Form的属性单独控制各个Field的输出，有比较繁琐。</p>
<p>为了减少重复工作，便于样式化修改，考虑利用template格式化FormField。</p>
<p><code>Django Widget</code>的渲染可以由模板控制，模板的路径在<code>Widget.template_name</code>中设置。</p>
<p><code>Widget.render()</code>方法会调用<code>Widget._render()</code>方法，这个方法能够根据指定的template，生成HTML代码段。</p>
<p><code>Widget.render()</code>方法会调用<code>Widget.get_context()</code>方法，生成渲染field对应HTML代码所需要的上下文。<br>因为默认实现中，生成上下文的过程中会自动将value转化为字符串形式，这不是我们想要的结果，所以我们还需要重写<code>Widget.get_context()</code>方法。</p>
<p>为了能够方便的控制模板的渲染，在FormField的初始化参数中增加了<code>using_template</code>和<code>template_name</code>参数。当<code>using_template == True</code>时，使用模板渲染FormField（而不是简单的<code>as_table()</code>)；<code>template_name</code>用于指定模板路径，用于覆盖Widget设置的默认模板路径。</p>
<p>同时还需要重写<code>BoundFormField.as_widget()</code>方法，在它调用<code>Widget.render()</code>方法的时候将<code>using_template</code>和<code>template_name</code>传入。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># in BaseFormField class definition</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">as_widget</span><span class="params">(self, widget=None, attrs=None, only_initial=False,</span></span></div><div class="line">        using_template=None, template_name=None):</div><div class="line">    <span class="keyword">if</span> using_template <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        using_template = self.field.using_template <span class="keyword">or</span> <span class="keyword">False</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> template_name <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        template_name = self.field.template_name</div><div class="line"></div><div class="line">    <span class="comment"># 一下代码段为Django的源码</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> widget:</div><div class="line">        widget = self.field.widget</div><div class="line"></div><div class="line">    <span class="keyword">if</span> self.field.localize:</div><div class="line">        widget.is_localized = <span class="keyword">True</span></div><div class="line"></div><div class="line">    attrs = attrs <span class="keyword">or</span> &#123;&#125;</div><div class="line">    attrs = self.build_widget_attrs(attrs, widget)</div><div class="line">    auto_id = self.auto_id</div><div class="line">    <span class="keyword">if</span> auto_id <span class="keyword">and</span> <span class="string">'id'</span> <span class="keyword">not</span> <span class="keyword">in</span> attrs <span class="keyword">and</span> <span class="string">'id'</span> <span class="keyword">not</span> <span class="keyword">in</span> widget.attrs:</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> only_initial:</div><div class="line">            attrs[<span class="string">'id'</span>] = auto_id</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            attrs[<span class="string">'id'</span>] = self.html_initial_id</div><div class="line"></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> only_initial:</div><div class="line">        name = self.html_name</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        name = self.html_initial_name</div><div class="line"></div><div class="line">    kwargs = &#123;&#125;</div><div class="line">    <span class="keyword">if</span> func_supports_parameter(widget.render, <span class="string">'renderer'</span>) <span class="keyword">or</span>\</div><div class="line">            func_accepts_kwargs(widget.render):</div><div class="line">        kwargs[<span class="string">'renderer'</span>] = self.form.renderer</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        warnings.warn(</div><div class="line">            <span class="string">'Add the `renderer` argument to the render() method of %s. '</span></div><div class="line">            <span class="string">'It will be mandatory in Django 2.1.'</span> % widget.__class__,</div><div class="line">            RemovedInDjango21Warning, stacklevel=<span class="number">2</span>,</div><div class="line">        )</div><div class="line">    <span class="keyword">return</span> widget.render(</div><div class="line">        name=name,</div><div class="line">        value=self.value(),</div><div class="line">        attrs=attrs,</div><div class="line">        context=self.get_render_context(),</div><div class="line">        using_template=using_template,</div><div class="line">        template_name=template_name,</div><div class="line">        **kwargs</div><div class="line">    )</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormInput</span><span class="params">(Widget)</span>:</span></div><div class="line">    template_name = <span class="string">'form_field_utils/form_input.html'</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">render</span><span class="params">(self, name, value, attrs=None, renderer=None,</span></span></div><div class="line">            context=None, using_template=None, template_name=None):</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> using_template:</div><div class="line">            <span class="keyword">return</span> value.as_table()</div><div class="line"></div><div class="line">        template_name = template_name <span class="keyword">or</span> self.template_name</div><div class="line">        context = self.get_context(name, value, attrs, context, template_name)</div><div class="line">        <span class="keyword">return</span> self._render(template_name, context, renderer)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">value_from_datadict</span><span class="params">(self, data, files, name)</span>:</span></div><div class="line">        <span class="keyword">return</span> data</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_context</span><span class="params">(self, name, value, attrs, context=None, template_name=None)</span>:</span></div><div class="line">        ctx = super().get_context(name, value, attrs)</div><div class="line">        ctx[<span class="string">'widget'</span>][<span class="string">'template_name'</span>] = template_name</div><div class="line">        ctx[<span class="string">'form'</span>] = value</div><div class="line">        context.update(ctx)</div><div class="line">        <span class="keyword">return</span> context</div></pre></td></tr></table></figure>
<p>一个简单的内层Form模板实现：<br><img src="/2017/07/19/django-custom-FormField/t_template.png" alt="内层Form模板"></p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ol>
<li><code>ModelFormField</code>相关的实现，在下篇文章记录。</li>
<li>在这个实现中，没有考虑与<code>FileField</code>等Field类型的情况，今后学习了有关表单文件处理的代码之后再慢慢完善。</li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/2017/07/14/custom-django-admin-command/" class="prev">PREV</a><a href="/2017/07/23/django-custom-ModelFormField/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2017 <a href="https://resettingmq.github.io">resettingmq</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>