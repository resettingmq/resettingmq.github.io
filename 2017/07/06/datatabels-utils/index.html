<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> DataTables utils 开发笔记 - 1. 整体架构 · Keep mind occupied</title><meta name="description" content="DataTables utils 开发笔记 - 1. 整体架构 - resettingmq"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://resettingmq.github.io/atom.xml" title="Keep mind occupied"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">DataTables utils 开发笔记 - 1. 整体架构</h1><div class="post-info">2017年7月6日</div><div class="post-content"><blockquote>
<p>简单实例页面：<a href="http://django.resettingmq.top/client/" target="_blank" rel="external">客户-案件管理系统</a></p>
</blockquote>
<h2 id="目标功能"><a href="#目标功能" class="headerlink" title="目标功能"></a>目标功能</h2><ol>
<li>通过ModelDataTable类定义，设置DataTables所需要的meta信息；</li>
<li>通过template tags，能够在template中输出HTML table表头；</li>
<li>通过template tags，能够在template中生成javascript代码段；</li>
</ol>
<h2 id="ModelDataTable类"><a href="#ModelDataTable类" class="headerlink" title="ModelDataTable类"></a>ModelDataTable类</h2><p>类似于<code>Django</code>的<code>ModelForm</code>，<code>ModelDataTables</code>能够：</p>
<ol>
<li>通过<code>Meta</code>类的定义，从<code>model</code>中自动生成所需要的<code>DataTables column</code>信息；</li>
<li>在该类的子类中，能够声明式的建立<code>DataTables column</code>信息；</li>
</ol>
<p><code>DataTables column</code>信息对应<code>DataTables</code>的<code>columns</code>配置项。其它的配置项（例如<code>serverSide</code>, <code>ajax</code>等）通过类属性的方式定义。</p>
<p>为了避免与其它类属性产生冲突，约定这些类属性以<code>dt_</code>为前缀。</p>
<p>为了能够在template中生成对<code>DataTables</code>的初始化配置数据，还需要能够将这些配置数据以正确的结构构建成<code>dict</code>形式（或者返回正确结构的方法），方便在模板中输出。</p>
<p>由于<code>Django</code>没有提供内建的<code>JSON filter</code>，所以还需要实现这个<code>filter</code>（具体的实现在<a href="https://resettingmq.github.io/2017/07/06/template-tags/">下一篇</a>文章中提出）。（当然也可以在这个类中实现方法，将配置<code>dict</code>序列化成<code>JSON</code>字符串后再在template中直接输出。)</p>
<p><code>Meta class</code>中的属性：</p>
<ul>
<li>model（必须要定义）</li>
<li>column_order</li>
<li>fields</li>
<li>detail_url_format<br>  这个值是一个接受一个位置格式化参数的字符串。如果没有指定这个值，则前端输出的代码不会自动添加对于DataTables行的单击处理事件；如果指定了这个值，就会在前端javascript代码中添加DataTables行的单击处理事件（需要通过template tags输出），并且在单击行时，会发送请求到这个值指定的url。</li>
</ul>
<p>可以通过元类来实现这些功能。</p>
<h2 id="ModelDataTablesMetaClass"><a href="#ModelDataTablesMetaClass" class="headerlink" title="ModelDataTablesMetaClass"></a>ModelDataTablesMetaClass</h2><p>这个类作为<code>ModelDataTables</code>的元类。<br>通过这个元类，</p>
<ul>
<li>能够检查<code>Meta class</code>以及定义在其中的<code>model</code>等属性；</li>
<li>能够处理<code>ModelDataTables</code>子类中声明的<code>ModelDataTablesColumn</code>类型的属性，将其作为配置数据；</li>
<li>能够保持<code>ModelDataTables</code>子类中声明属性的顺序；</li>
<li><del>为<code>ModelDataTables</code>的子类在声明时生成一个包含随机数的id；</del></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelDataTablesMetaClass</span><span class="params">(type)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(mcls, name, bases, attrs)</span>:</span></div><div class="line">        <span class="comment"># ... some code ...</span></div><div class="line">        d = dict(attrs)</div><div class="line">        declared_columns = []</div><div class="line">        <span class="keyword">for</span> name, value <span class="keyword">in</span> attrs.items():</div><div class="line">            <span class="keyword">if</span> isinstance(value, DataTablesColumn):</div><div class="line">                <span class="comment"># 为了能处理对related model的处理，属性名采用了类似Django的</span></div><div class="line">                <span class="comment"># attr__related_attr的属性路径表达方式.</span></div><div class="line">                <span class="comment"># 下面这个函数实现了根据属性路径获取到相应field的功能</span></div><div class="line">                field = _get_field(model, name)</div><div class="line">                <span class="keyword">if</span> field <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                value.name = name</div><div class="line">                value.field = field</div><div class="line">                declared_columns.append((name, value))</div><div class="line">                d.pop(name)</div><div class="line">        <span class="comment"># 采用OrderedDict保存，方便查询的同时，保证顺序</span></div><div class="line">        d[<span class="string">'_declared_columns'</span>] = OrderedDict(declared_columns)</div><div class="line"></div><div class="line">        <span class="comment"># 采用类似的方法，处理在Meta中指定的fields信息</span></div><div class="line">        meta_defined_columns = []</div><div class="line">        field_names = getattr(meta, <span class="string">'fields'</span>, [])</div><div class="line">        titles = getattr(meta, <span class="string">'titles'</span>, &#123;&#125;)</div><div class="line">        <span class="keyword">for</span> field_name <span class="keyword">in</span> field_names:</div><div class="line">            field = _get_field(model, field_name)</div><div class="line">            <span class="keyword">if</span> field <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            dt_column = DataTablesColumn.get_instance_from_field(field)</div><div class="line">            dt_column.name = field_name</div><div class="line">            <span class="keyword">if</span> titles.get(field_name):</div><div class="line">                dt_column.title = titles.get(field_name)</div><div class="line">            meta_defined_columns.append((field_name, dt_column))</div><div class="line">        d[<span class="string">'_meta_defined_columns'</span>] = OrderedDict(meta_defined_columns)</div><div class="line"></div><div class="line">        <span class="comment"># ... some other code ...</span></div><div class="line"></div><div class="line"><span class="meta">    @classmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__prepare__</span><span class="params">(mcls, name, bases)</span>:</span></div><div class="line">        <span class="comment"># 重写这个方法，返回OrderedDict的实例，</span></div><div class="line">        <span class="comment"># 保证类声明中属性定义的顺序</span></div><div class="line">        <span class="keyword">return</span> OrderedDict()</div></pre></td></tr></table></figure>
<h2 id="DataTables-columns-顺序"><a href="#DataTables-columns-顺序" class="headerlink" title="DataTables columns 顺序"></a>DataTables columns 顺序</h2><p>在HTML table中column需要按照指定顺序生成header。<br>（返回的JSON数据没有顺序信息，这些数据会根据key映射到对应的HTML table column中）</p>
<ol>
<li>可以通过<code>column_order</code>指定顺序，这种情况下，<code>column_order</code>需要包含所有声明的column以及Meta中指定的column；</li>
<li>如果没有指定<code>column_order</code>，则声明的column排在Meta中通过<code>fields</code>指定的column的前面；</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># code in ModelDataTableMetaClass definition</span></div><div class="line"></div><div class="line"><span class="comment"># 处理两种columns源的order，并生成最终的columns属性</span></div><div class="line">column_order = getattr(meta, <span class="string">'column_order'</span>, <span class="keyword">None</span>)</div><div class="line"><span class="keyword">if</span> column_order <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">    columns = OrderedDict(declared_columns)</div><div class="line">    <span class="keyword">for</span> name, column <span class="keyword">in</span> d[<span class="string">'_meta_defined_columns'</span>].items():</div><div class="line">        <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> columns:</div><div class="line">            columns[name] = column</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    columns = OrderedDict()</div><div class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> column_order:</div><div class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> d[<span class="string">'_declared_columns'</span>]:</div><div class="line">            columns[name] = d[<span class="string">'_declared_columns'</span>][name]</div><div class="line">        <span class="keyword">elif</span> name <span class="keyword">in</span> d[<span class="string">'_meta_defined_columns'</span>]:</div><div class="line">            columns[name] = d[<span class="string">'_meta_defined_columns'</span>][name]</div><div class="line">d[<span class="string">'columns'</span>] = columns</div></pre></td></tr></table></figure>
<h2 id="DataTablesColumn类"><a href="#DataTablesColumn类" class="headerlink" title="DataTablesColumn类"></a>DataTablesColumn类</h2><p><code>DataTablesColumn</code>类的实例用来保存DataTables中列的配置信息，并提供一系列的方法，用于返回该<code>DataTablesColumn</code>对象相关的数据信息。</p>
<p>在通过声明的方式生成<code>DataTablesColumn</code>实例的情况下，这些信息可以通过<code>DataTablesColumn</code>类初始化的关键字参数指定；</p>
<p>而在通过<code>ModelDataTable</code>子类的<code>Meta</code>隐式自动生成<code>DataTableColumn</code>实例的时候，这些配置信息部分从绑定到的Model Field实例信息获取。</p>
<blockquote>
<p>可惜的是，<code>Django</code>内建的<code>Field</code>类型初始化时并不接受额外的关键字参数，除非使用自定义<code>Field</code>类型。所以不能通过在<code>Model-Field</code>定义的时候指定<code>DataTables</code>列相关的配置参数。</p>
</blockquote>
<p><code>DataTablesColumn.title</code><br>用来指定HTML table的header部分显示的信息。<br>在没有设置的时候，默认获取对应field实例的verbose_name属性。</p>
<p><code>DataTablesColumn.width</code><br>指定column在HTML Table中显示的宽度</p>
<p><code>DataTablesColumn.searchable</code><br>指定column是否可以被搜索。<br>默认为<code>True</code>。</p>
<p><code>DataTablesColumn.orderable</code><br>指定column是否可以排序。<br>默认为<code>True</code>。</p>
<p>下面是部分<code>DataTableColumn</code>类的定义（只包含对<code>title</code>配置的处理）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataTableColumn</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, title=None, field=None, **kwargs)</span>:</span></div><div class="line">        self.title = title</div><div class="line">        self.searchable = searchable</div><div class="line">        self.orderable = orderable</div><div class="line">        <span class="keyword">if</span> field <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">            self._initialize_from_field(field)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self._bound = <span class="keyword">False</span></div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">field</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># 不能直接读field属性</span></div><div class="line">        <span class="keyword">raise</span> AttributeError(<span class="string">'Attribute field not defined, try _field'</span>)</div><div class="line"></div><div class="line"><span class="meta">    @field.setter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">field</span><span class="params">(self, value)</span>:</span></div><div class="line">        <span class="comment"># 绑定到对应field实例</span></div><div class="line">        self._initialize_from_field(value)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_initialize_from_field</span><span class="params">(self, field)</span>:</span></div><div class="line">        <span class="comment"># ... some code ...</span></div><div class="line">        <span class="keyword">if</span> self.title <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="comment"># 如果初始化时没有指定title，则使用绑定field的verbose name</span></div><div class="line">            self.title = field.verbose_name</div><div class="line">        self._field = field</div><div class="line">        self._bound = <span class="keyword">True</span></div><div class="line">        <span class="keyword">if</span> field.is_relation:</div><div class="line">            <span class="comment"># 如果指定的field为ForeignKey, OneToOne等relationship</span></div><div class="line">            <span class="comment"># 则该列强制为不能搜索</span></div><div class="line">            self.searchable = <span class="keyword">False</span></div><div class="line"></div><div class="line"><span class="meta">    @classmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_instance_from_field</span><span class="params">(cls, field)</span>:</span></div><div class="line">        <span class="comment"># 类方法，根据指定的field生成实例</span></div><div class="line">        <span class="keyword">return</span>  cls(field=field)</div><div class="line"></div><div class="line">    <span class="comment"># ... some other method definitions ...</span></div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里实现了ModelDataTable的基本配置了，在下一篇文章（<a href="https://resettingmq.github.io/2017/07/05/datatables-with-django/">datatabels_utils 开发笔记 - 请求的处理</a>）中将在这些配置信息的基础之上，完成请求响应的逻辑以及模板的渲染。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/05/30/Werkzeug-Thread-Local学习/" class="prev">上一篇</a><a href="/2017/07/06/datatables-with-django/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2017 <a href="https://resettingmq.github.io">resettingmq</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>