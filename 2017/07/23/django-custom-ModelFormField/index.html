<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Django FormField 实现笔记 二 · Keep mind occupied</title><meta name="description" content="Django FormField 实现笔记 二 - resettingmq"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://resettingmq.github.io/atom.xml" title="Keep mind occupied"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Django FormField 实现笔记 二</h1><div class="post-info">2017年7月23日</div><div class="post-content"><p>这篇文章继续记录实现ModelFormField的过程。</p>
<p>最终实现的效果可以通过<a href="http://demo.resettingmq.top/formfield/model/" target="_blank" rel="external">这里</a>查看。</p>
<p>ModelFormField继承自FormField，在FormField的基础上实现。</p>
<p>为了简单，在这一阶段的实现当中，先做一下约定：</p>
<blockquote>
<p>ModelFormField对应的model中存在一个到外层ModelForm的<code>OneToOneField</code>，即外层ModelForm中存在一个<code>OneToOneRel</code>属性(reverse relationship)指向内层model的实例。</p>
<p>其它的外键关联情况之后再实现。 </p>
</blockquote>
<h1 id="ModelFormField与FormField的异同"><a href="#ModelFormField与FormField的异同" class="headerlink" title="ModelFormField与FormField的异同"></a>ModelFormField与FormField的异同</h1><p>ModelFormField与FormField在生成HTML部分的逻辑是一致的，不同的部分主要集中在数据处理的部分：</p>
<ol>
<li>ModelFormField能够接受<code>instance</code>初始化参数</li>
<li>ModelFormField提供save()方法</li>
</ol>
<h1 id="如何将OneToOneRel对应的field添加进ModelForm"><a href="#如何将OneToOneRel对应的field添加进ModelForm" class="headerlink" title="如何将OneToOneRel对应的field添加进ModelForm"></a>如何将<code>OneToOneRel</code>对应的field添加进ModelForm</h1><p>Djangod的ModelForm通过Meta.fields/exclude指定ModelForm中Fields的时候，会将范围缩小在<code>concrete_fields</code>, <code>private_fields</code>, <code>many_to_many</code>范围之内。所以在Meta.fields中指定<code>OneToOneRel</code>对象的field name会被忽略，最终生成的Form将不会对<code>OneToOneRel</code>对应的field进行渲染，认证已经生成cleaned_data。</p>
<p>但是，通过声明的方式在ModelForm中添加FormField的field则不会做检查，直接添加到<code>ModelForm.fields</code>属性当中（这个属性在ModelForm实例化的时候会被深拷贝到ModelForm对象的fields属性上）。</p>
<p>例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Model Definition</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span><span class="params">(models.Model)</span>:</span></div><div class="line">    order_sn = models.CharField(max_length=<span class="number">100</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contract</span><span class="params">(models.Model)</span>:</span></div><div class="line">    contract_sn = models.CharField(max_length=<span class="number">100</span>)</div><div class="line">    order = models.OneToOneField(Order)</div><div class="line"></div><div class="line"><span class="comment"># Form Definition</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContractModelForm</span><span class="params">(forms.ModelForm)</span>:</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></div><div class="line">        model = Contract</div><div class="line">        fields = <span class="string">'__all__'</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderModelForm</span><span class="params">(forms.ModelForm)</span>:</span></div><div class="line">    <span class="comment"># 通过声明的方式添加OneToOneRel field对应的form field</span></div><div class="line">    contract = ModelFormField(</div><div class="line">        ContractModelForm,</div><div class="line">    )</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></div><div class="line">        model = Order</div><div class="line">        fields = <span class="string">'__all__'</span></div></pre></td></tr></table></figure></p>
<h1 id="instance参数"><a href="#instance参数" class="headerlink" title="instance参数"></a>instance参数</h1><p>ModelForm的instance参数指定的对象，将与initial参数指定的值共同为ModelForm提供渲染的初始值，这一个过程发生在ModelForm的<code>__init__()</code>当中。</p>
<p>所以为了能够使提供的instance参数能够被正常在模板中渲染，需要在内层ModelForm初始化之前提供instance参数。</p>
<p>先分析Django ModelForm初始化与instance相关的部分：</p>
<p>初始化参数<code>instance</code>会在ModelForm初始化过程中生成一个对应的dict形式<code>object_data</code>，并结合<code>initial</code>参数值，作为最终Form的<code>initial</code>初始化参数（ModelForm的<code>initial</code>初始化参数会覆盖<code>object_data</code>中的相应值。</p>
<p><code>instance</code>生成<code>object_data</code>过程中，对<code>instance</code>属性的筛选逻辑：</p>
<ol>
<li><code>instance</code>的<code>concrete_fields</code>, <code>private_fields</code>, <code>many_to_many</code>；</li>
<li>必须是<code>editable</code>;</li>
<li>必须在ModelForm指定生成个的fields中；</li>
<li>必须不在ModelForm的exclude指定范围中。</li>
</ol>
<p>可以看到：</p>
<ol>
<li><code>OneToOneRel</code>类型的属性不会被添加到<code>object_data</code>中；</li>
<li>对于<code>OneToOneField</code>以及<code>ForeignKey</code>，被添加到<code>object_dict</code>中的是<code>foreign key</code>的值而不是整个关联对象。</li>
</ol>
<blockquote>
<p><code>instance</code>中的<code>OneToOneRel</code>属性不会传递到生成Form的<code>initial</code>参数中。</p>
</blockquote>
<p>内层ModelForm的在初始化之前应该能够从外层ModelForm的<code>instance</code>属性中获取到自身对应的<code>instance</code>。因此，考虑在<code>BoundModelFormField</code>中实现<code>property instance</code>：</p>
<ol>
<li>尝试从外层Form的instance的对应属性中获取内层ModelForm的instance（如果外层Form不是ModelForm，则没有instance属性，需要进行判断）；</li>
<li>如果外层ModelForm没有指定instance，则尝试从ModelFormField的instance属性获取；</li>
<li>如果ModelFormField上也没有指定instance属性，则返回None。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># code in BoundModelFormField definition</span></div><div class="line"></div><div class="line"><span class="meta">@property</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">instance</span><span class="params">(self)</span>:</span></div><div class="line"><span class="keyword">return</span> getattr(self.form, <span class="string">'instance'</span>, <span class="keyword">None</span>) <span class="keyword">and</span> \</div><div class="line">    getattr(self.form.instance, self.name, <span class="keyword">None</span>) <span class="keyword">or</span> \</div><div class="line">    self.field.instance</div></pre></td></tr></table></figure>
<p>同时，还需要重写<code>BoundModelFormField._get_form()</code>方法，在生成form实例的时候添加进<code>instance</code>初始化参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># code in BoundModelFormField definition</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_form</span><span class="params">(self, **kwargs)</span>:</span></div><div class="line">    kwargs[<span class="string">'instance'</span>] = self.instance</div><div class="line">    <span class="keyword">return</span> super()._get_form(**kwargs)</div></pre></td></tr></table></figure>
<h1 id="save-方法"><a href="#save-方法" class="headerlink" title="save()方法"></a>save()方法</h1><p>我们希望在外层ModelForm调用<code>save()</code>方法的过程中，自动调用内层ModelForm的<code>save()</code>方法并确保两者的关联关系。</p>
<p>为此，需要在Mixin中重新实现<code>ModelForm.save()</code>方法，在外层ModelForm执行<code>save()</code>的过程中，执行所有内层ModelForm的<code>save()</code>方法。</p>
<p>Django ORM与SQLAlchemy ORM系统不同，SQLAlchemy ORM是通过<code>session</code>对象对整个<code>ORM catelog</code>进行管理，会自动处理关联对象的保存和更新；而Django ORM的保存操作发生在单个对象上，不会自动保存和更新相关联的对象。<br>在文章开头的前提约定之下（即内层ModelForm的model存在<code>OneToOneField</code>指向外层ModelForm的model），为了保证内外层ModelForm对应model之间关系能够正确保存，应该先保存外层ModelForm，获取外层对象的pk值，关联内层对象后再保存内层对象。</p>
<p>这一保存逻辑只能在参数<code>commit=True</code>的情况下实现。如果<code>commit=False</code>，用户需要手动关联内外层对象（新建对象的情况下）。</p>
<p>同时，还需要保证内外层ModelForm.save()操作的原子性，即在内层ModelForm保存失败的情况下，外层ModelForm instance的保存操作会被rollback。</p>
<p>在<code>save()</code>方法中增加了<code>before_save_related()</code>方法，方便在子类中重写该方法，使得能够在保存内层关联对象之前，对这些对象进行一些设置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># code in ModelFormFieldSupportMixin definition</span></div><div class="line"></div><div class="line"><span class="meta">@transaction.atomic</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self. commit=True)</span>:</span></div><div class="line">    outer_obj = super().save(commit=commit)</div><div class="line">    self.before_save_related()</div><div class="line">    self.save_related(commit=commit)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> outer_obj</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_related</span><span class="params">(self, commit=True)</span>:</span></div><div class="line">    <span class="comment"># 建立inner instance和outer instance的关系</span></div><div class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> self.modelform_fields:</div><div class="line">        setattr(self.instance, name, self[name].inner_form.instance)</div><div class="line">        self[name].save(commit=commit)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">before_save_related</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<blockquote>
<p>需要保证外层ModelForm继承自<code>ModelFormFieldSupportMixin</code>。</p>
</blockquote>
<h1 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h1><p>这些坑主要是在测试的过程中遇到的，有助于提高对Django执行原理的理解：</p>
<ol>
<li><p>作为初始化参数的instance在ModelForm验证过程中会被验证通过的值修改！我在两个测试样例中用了同一个全局的instance，发现两个测试样例的结果互相耦合。一直以为是ModelFormField的实现中逻辑有错误，花了很长时间debug。。。</p>
</li>
<li><p>对于required=False的ModelForm Field，如果传入的data中没有这个Field对应的值，则在验证过程后返回Field类型对应的默认值，并将这个默认值作为<code>save()</code>方法最终返回instance对应属性的值，而不是初始化参数instance中对应属性的值。例如，一个required=False的CharField，如果传入的data为None，则验证过程中会转换成空字符串，最终save()的结果对应属性值为空字符串，而不是初始化参数instance中对应属性的值，初始化参数instance响应的属性值会被设置为空字符串。</p>
</li>
<li><p>如果在内层ModelForm的field中包含了指向外层ModelForm的field，这个field是会被传入的data值修改的。所以在<code>save(commit=True)</code>的过程中，即使将内层form的instance的关联属性指向外层form的instance，最终在内层form调用<code>save()</code>的过程中被data值覆盖掉。<br> 解决这个Bug的一个方案是：在内层ModelForm实例化的过程中，将指向外层ModelForm的Field去除掉。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># code in ModelFormFieldSupportMixin.__init__()</span></div><div class="line"></div><div class="line"><span class="comment"># 用于删除inner form指向outer model的field</span></div><div class="line"><span class="keyword">for</span> inner_field_name <span class="keyword">in</span> list(self[name].inner_form.fields):</div><div class="line">    <span class="keyword">if</span> inner_opts.get_field(inner_field_name).related_model <span class="keyword">is</span> outer_model:</div><div class="line">        self[name].inner_form.fields.pop(inner_field_name)</div></pre></td></tr></table></figure></div></article></div></main><footer><div class="paginator"><a href="/2017/07/19/django-custom-FormField/" class="prev">上一篇</a></div><div class="copyright"><p>© 2015 - 2017 <a href="https://resettingmq.github.io">resettingmq</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>