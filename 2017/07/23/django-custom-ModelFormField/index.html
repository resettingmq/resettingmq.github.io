<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Django FormField 实现笔记 二 · Keep mind occupied</title><meta name="description" content="Django FormField 实现笔记 二 - resettingmq"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://resettingmq.github.io/atom.xml" title="Keep mind occupied"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Django FormField 实现笔记 二</h1><div class="post-info">2017年7月23日</div><div class="post-content"><p>这篇文章继续记录实现ModelFormField的过程。</p>
<p>ModelFormField继承自FormField，在FormField的基础上实现。</p>
<p>为了简单，在这一阶段的实现当中，先做一下约定：</p>
<blockquote>
<p>ModelFormField对应的model中存在一个到外层ModelForm的<code>oneToOneField</code>，即外层ModelForm中存在一个<code>OneToOneRel</code>属性指向内层model的实例。</p>
<p>其它的外键关联情况之后再实现。 </p>
</blockquote>
<h1 id="ModelFormField与FormField的异同"><a href="#ModelFormField与FormField的异同" class="headerlink" title="ModelFormField与FormField的异同"></a>ModelFormField与FormField的异同</h1><p>ModelFormField与FormField在生成HTML部分的逻辑是一致的，不同的部分主要集中在数据处理的部分：</p>
<ol>
<li>ModelForm能够接受<code>instance</code>初始化参数</li>
</ol>
<h1 id="内层ModelForm的匹配"><a href="#内层ModelForm的匹配" class="headerlink" title="内层ModelForm的匹配"></a>内层ModelForm的匹配</h1><p><del>在外层ModelForm中声明ModelFormField的时候，需要对内层ModelForm的model进行匹配检查。如果这个model与外层ModelForm的model对应<code>OneToOneRel</code>不匹配的情况下，就会报错。</del></p>
<p><del>这个逻辑需要在元类中实现。</del></p>
<p>因为在ModelForm声明时进行类型检查，需要内层ModelForm已经定义，所以容易造成循环引用。所以改在ModelForm实例化的时候进行内外层Model的匹配检查。</p>
<h1 id="instance参数"><a href="#instance参数" class="headerlink" title="instance参数"></a>instance参数</h1><p>ModelForm的instance参数指定的对象，将与initial参数指定的值共同为ModelForm提供渲染的初始值，这一个过程发生在ModelForm的<code>__init__()</code>当中。</p>
<p>所以为了能够使提供的instance参数能够被正常在模板中渲染，需要在内层ModelForm初始化之前提供instance参数。</p>
<p>初始化参数<code>instance</code>会在ModelForm初始化过程中生成一个对应的dict形式<code>object_data</code>，并结合<code>initial</code>参数值，作为最终Form的<code>initial</code>初始化参数（ModelForm的<code>initial</code>初始化参数会覆盖<code>object_data</code>中的相应值。</p>
<p><code>instance</code>生成<code>object_data</code>过程中，对<code>instance</code>属性的筛选逻辑：</p>
<ol>
<li><code>instance</code>的<code>concrete_fields</code>, <code>private_fields</code>, <code>many_to_many</code>；</li>
<li>必须是<code>editable</code>;</li>
<li>必须在ModelForm指定生成个的fields中；</li>
<li>必须不在ModelForm的exclude指定范围中。</li>
</ol>
<p>注意：</p>
<ol>
<li><code>OneToOneRel</code>类型的属性不会被添加到<code>object_data</code>中；</li>
<li>对于<code>OneToOneField</code>以及<code>ForeignKey</code>，被添加到<code>object_dict</code>中的是<code>foreign key</code>的值而不是整个关联对象。</li>
</ol>
<p>所以，<code>instance</code>中的<code>OneToOneRel</code>属性不会传递到生成Form的<code>initial</code>参数中。</p>
<p>内层ModelForm的在初始化之前应该能够从外层ModelForm的<code>instance</code>属性中获取到自身对应的<code>instance</code>。在<code>BoundModelFormField</code>中实现<code>property instance</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">instance</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># 在inner_form实例化之前，从outer_form的instance获取instance</span></div><div class="line">        <span class="comment"># 或者在ModelFormField上获取instance</span></div><div class="line">        instance = getattr(self.form.instance, self.name, <span class="keyword">None</span>) <span class="keyword">or</span> self.field.instance</div><div class="line"></div><div class="line">        <span class="keyword">return</span> instance</div></pre></td></tr></table></figure>
<p>同时，还需要重写<code>BoundModelFormField.inner_form</code>属性，在获取inner_form的时候添加进<code>instance</code>初始化参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@cached_property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_form</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.form.is_bound:</div><div class="line">            <span class="keyword">return</span> self.field.get_form(self.form.data, self.initial, self.instance)</div><div class="line">        <span class="keyword">return</span> self.field.get_form(initial=self.initial, instance=self.instance)</div></pre></td></tr></table></figure>
<h1 id="Meta-fields-exclude"><a href="#Meta-fields-exclude" class="headerlink" title="Meta.fields/exclude"></a>Meta.fields/exclude</h1><p>在ModelForm通过Meta.fields/exclude指定ModelForm中Fields的时候，同样会将范围缩小在<code>concrete_fields</code>, <code>private_fields</code>, <code>many_to_many</code>范围之内。所以在Meta.fields中指定<code>OneToOneRel</code>对象的field name就会被忽略。</p>
<p>但是通过声明的方式常见FormField的field则不会做检查，直接添加到FormField.fields属性当中。</p>
<blockquote>
<p>这一块相关内容以后再实现。因为涉及到根据model field的类型自动选择form field的类型，所以可能涉及到修改代码的部分比较多且逻辑复杂。</p>
</blockquote>
<h1 id="save-方法"><a href="#save-方法" class="headerlink" title="save()方法"></a>save()方法</h1><p>我们希望在外层ModelForm调用<code>save()</code>方法的过程中，自动调用内层ModelForm的<code>save()</code>方法并确保两者的关联关系。</p>
<p>为此，需要在Mixin中重新实现<code>ModelForm.save()</code>方法，在外层ModelForm执行<code>save()</code>的过程中，执行所有内层ModelForm的<code>save()</code>方法。</p>
<p>在文章开头的前提约定之下（即内层ModelForm的model存在<code>OneToOneField</code>指向外层ModelForm的model），为了保证内外层ModelForm对应model之间关系能够正确保存，应该先保存外层ModelForm，获取外层对象的pk值，关联内层对象后再保存内层对象。</p>
<p>这一保存逻辑只能在参数<code>commit=True</code>的情况下实现。如果<code>commit=False</code>，用户需要手动关联内外层对象（新建对象的情况下）。</p>
<p>同时，还需要保证内外层ModelForm.save()操作的原子性。</p>
<h1 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h1><p>这些坑主要是在测试的过程中遇到的，有助于提高对Django执行原理的理解：</p>
<ol>
<li><p>作为初始化参数的instance在ModelForm验证过程中会被验证通过的值修改！我在两个测试样例中用了同一个全局的instance，发现两个测试样例的结果互相耦合。一直以为是ModelFormField的实现中逻辑有错误，花了很长时间debug。。。</p>
</li>
<li><p>对于required=False的ModelForm Field，如果传入的data中没有这个Field对应的值，则在验证过程后返回Field类型对应的默认值，并将这个默认值作为<code>save()</code>方法最终返回instance对应属性的值，而不是初始化参数instance中对应属性的值。例如，一个required=False的CharField，如果传入的data为None，则验证过程中会转换成空字符串，最终save()的结果对应属性值为空字符串，而不是初始化参数instance中对应属性的值，初始化参数instance响应的属性值会被设置为空字符串。</p>
</li>
<li><p>如果在内层ModelForm的field中包含了指向外层ModelForm的field，这个field是会被传入的data值修改的。所以在<code>save(commit=True)</code>的过程中，即使将内层form的instance的关联属性指向外层form的instance，最终在内层form调用<code>save()</code>的过程中被data值覆盖掉。<br> 解决这个Bug的一个方案是：在内层ModelForm实例化的过程中，将指向外层ModelForm的Field去除掉。</p>
</li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/2017/07/19/django-custom-FormField/" class="prev">上一篇</a></div><div class="copyright"><p>© 2015 - 2017 <a href="https://resettingmq.github.io">resettingmq</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>