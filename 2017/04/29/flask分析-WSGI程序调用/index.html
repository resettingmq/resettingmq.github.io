<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> flask分析_WSGI程序调用 · Keep mind occupied</title><meta name="description" content="flask分析_WSGI程序调用 - resettingmq"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://resettingmq.github.io/atom.xml" title="Keep mind occupied"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">flask分析_WSGI程序调用</h1><div class="post-info">2017年4月29日</div><div class="post-content"><h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>根据WSGI协议，<code>WSGI application</code>向<code>WSGI Server</code>提供一个可调用对象。当<code>WSGI Server</code>分发请求时，调用该对象，并将当前环境参数<code>environ</code>以及一个<code>callback</code>函数<code>start_response</code>传入该可调用对象。</p>
<h2 id="Flask-Application调用入口"><a href="#Flask-Application调用入口" class="headerlink" title="Flask Application调用入口"></a><code>Flask Application</code>调用入口</h2><p>先从最简单的<code>WSGI application</code>入手：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> flask</div><div class="line"></div><div class="line">app = flask.Flask(__name__)</div><div class="line"></div><div class="line"><span class="meta">@app.route('/')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'Hello, world!'</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    app.run(debug=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<p>在这段代码中，<code>app.run()</code>启动了<code>werkzeug</code>内建的一个简单的<code>WSGI Server</code>。启动这个<code>WSGI Server</code>的时候，将<code>Flask</code>的实例<code>app</code>作为可调用对象传入了<code>WSGI Server</code>。所以，要分析<code>WSGI</code>程序的调用过程，重点在于<code>WSGI Server</code>将请求分发到这个<code>WSGI application</code>的时候，<code>Flask</code>的实例<code>app</code>是如何被调用的。</p>
<p>先看<code>Flask.__call__()</code>的代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># flask/app.py</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flask</span><span class="params">(_PackageBoundObject)</span>:</span></div><div class="line">    <span class="comment"># ...</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, environ, start_response)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.self.wsgi_app(environ, start_response)</div><div class="line"></div><div class="line">    <span class="comment"># ...</span></div></pre></td></tr></table></figure>
<p>所以，在<code>app</code>对象被调用的时候，实际上调用了<code>app.wsgi_app(environ, start_response)</code>，也即，在<code>WSGI Server</code>分发处理请求时调用的是<code>app.wsgi_app(environ, start_response)</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># flask/app.py</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flask</span><span class="params">(_PackageBoundObject)</span>:</span></div><div class="line">    <span class="comment"># ...</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wsgi_app</span><span class="params">(self, environ, start_response)</span>:</span></div></pre></td></tr></table></figure>
<h2 id="Flask-wsgi-app-的基本执行流程"><a href="#Flask-wsgi-app-的基本执行流程" class="headerlink" title="Flask.wsgi_app()的基本执行流程"></a><code>Flask.wsgi_app()</code>的基本执行流程</h2><p>在<code>Flask</code>实例调用<code>wsgi_app()</code>的过程，主要分为一下几个步骤（暂时先忽略错误处理部分）：</p>
<ol>
<li>对传入的<code>environ</code>环境变量生成<code>RequestContext</code>，并<code>push</code>到<code>_request_ctx_stack</code>中；</li>
<li>分发请求，获取<code>Response</code>响应对象；</li>
<li>返回响应，并调用<code>WSGI Server</code>传入的<code>callback</code>:<code>start_response</code>；</li>
<li>从<code>_request_ctx_stack</code>中弹出当前<code>request_context</code>。</li>
</ol>
<p>下面从这几个部分进行分析：</p>
<h3 id="1-请求上下文RequestContext对象的生成"><a href="#1-请求上下文RequestContext对象的生成" class="headerlink" title="1. 请求上下文RequestContext对象的生成"></a>1. 请求上下文<code>RequestContext</code>对象的生成</h3><p><code>Flask.request_context(environ)</code>函数生成并返回一个请求上下文对象，这个对象是<code>flask.ctx.RequestContext</code>的实例。</p>
<blockquote>
<p><em>在命令行进行测试的过程中，也可以通过`Flask.test_request_context(</em>args, <em>*kwargs)`函数来得到一个请求上下文。</em></p>
</blockquote>
<p>请求上下文对象包括了</p>
<h3 id="2-请求分发"><a href="#2-请求分发" class="headerlink" title="2. 请求分发"></a>2. 请求分发</h3><p>请求分发包括以下顺序进行：</p>
<ol>
<li>执行用<code>before_first_request()</code>注册的函数（如果是该程序的第一次请求）；</li>
<li>执行用<code>url_value_processor()</code>注册的函数；</li>
<li>执行用<code>before_request()</code>注册的函数；如果其中有函数返回<code>non-None</code>的值，则直接跳到第5步；</li>
<li>分发请求，执行该请求<code>URL</code>对应的<code>view function</code></li>
<li>根据步骤3或步骤4的结果生成<code>response</code>对象</li>
<li>执行用<code>after_request()</code>注册的函数，处理并返回上一步生成的<code>response</code>对象，在这个过程中，可以修改<code>response</code>对象或者替换为全新的<code>response</code>对象；</li>
<li>处理<code>session</code>（如果使用<code>session</code>）</li>
</ol>
<p>其中，步骤1-3中的函数，先执行使用<code>Flask</code>实例对象装饰器注册的函数，再执行使用<code>Blueprint</code>实例对象装饰器注册的函数；用同一个装饰器注册的函数，按照它们在代码中先后的顺序执行。<br>而步骤6中的函数执行顺序则相反：先执行使用<code>Blueprint</code>实例对象装饰器注册的函数，再执行使用<code>Flask</code>实例对象装饰器注册的函数；用同一个装饰器注册的函数，按照它们再代码中先后的顺序相反的顺序执行。</p>
<h3 id="3-返回响应"><a href="#3-返回响应" class="headerlink" title="3. 返回响应"></a>3. 返回响应</h3></div></article></div></main><footer><div class="paginator"><a href="/2017/04/27/flask分析-routing/" class="prev">上一篇</a><a href="/2017/04/30/Werkzeug-Thread-Local学习/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2017 <a href="https://resettingmq.github.io">resettingmq</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>