<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Keep mind occupied</title>
  <subtitle>Life is resetting...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://resettingmq.github.io/"/>
  <updated>2017-07-27T08:38:39.930Z</updated>
  <id>https://resettingmq.github.io/</id>
  
  <author>
    <name>resettingmq</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Django FormField 实现笔记 二</title>
    <link href="https://resettingmq.github.io/2017/07/23/django-custom-ModelFormField/"/>
    <id>https://resettingmq.github.io/2017/07/23/django-custom-ModelFormField/</id>
    <published>2017-07-22T16:43:00.000Z</published>
    <updated>2017-07-27T08:38:39.930Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章继续记录实现ModelFormField的过程。</p>
<p>ModelFormField继承自FormField，在FormField的基础上实现。</p>
<p>为了简单，在这一阶段的实现当中，先做一下约定：</p>
<blockquote>
<p>ModelFormField对应的model中存在一个到外层ModelForm的<code>oneToOneField</code>，即外层ModelForm中存在一个<code>OneToOneRel</code>属性指向内层model的实例。</p>
<p>其它的外键关联情况之后再实现。 </p>
</blockquote>
<h1 id="ModelFormField与FormField的异同"><a href="#ModelFormField与FormField的异同" class="headerlink" title="ModelFormField与FormField的异同"></a>ModelFormField与FormField的异同</h1><p>ModelFormField与FormField在生成HTML部分的逻辑是一致的，不同的部分主要集中在数据处理的部分：</p>
<ol>
<li>ModelForm能够接受<code>instance</code>初始化参数</li>
</ol>
<h1 id="内层ModelForm的匹配"><a href="#内层ModelForm的匹配" class="headerlink" title="内层ModelForm的匹配"></a>内层ModelForm的匹配</h1><p><del>在外层ModelForm中声明ModelFormField的时候，需要对内层ModelForm的model进行匹配检查。如果这个model与外层ModelForm的model对应<code>OneToOneRel</code>不匹配的情况下，就会报错。</del></p>
<p><del>这个逻辑需要在元类中实现。</del></p>
<p>因为在ModelForm声明时进行类型检查，需要内层ModelForm已经定义，所以容易造成循环引用。所以改在ModelForm实例化的时候进行内外层Model的匹配检查。</p>
<h1 id="instance参数"><a href="#instance参数" class="headerlink" title="instance参数"></a>instance参数</h1><p>ModelForm的instance参数指定的对象，将与initial参数指定的值共同为ModelForm提供渲染的初始值，这一个过程发生在ModelForm的<code>__init__()</code>当中。</p>
<p>所以为了能够使提供的instance参数能够被正常在模板中渲染，需要在内层ModelForm初始化之前提供instance参数。</p>
<p>初始化参数<code>instance</code>会在ModelForm初始化过程中生成一个对应的dict形式<code>object_data</code>，并结合<code>initial</code>参数值，作为最终Form的<code>initial</code>初始化参数（ModelForm的<code>initial</code>初始化参数会覆盖<code>object_data</code>中的相应值。</p>
<p><code>instance</code>生成<code>object_data</code>过程中，对<code>instance</code>属性的筛选逻辑：</p>
<ol>
<li><code>instance</code>的<code>concrete_fields</code>, <code>private_fields</code>, <code>many_to_many</code>；</li>
<li>必须是<code>editable</code>;</li>
<li>必须在ModelForm指定生成个的fields中；</li>
<li>必须不在ModelForm的exclude指定范围中。</li>
</ol>
<p>注意：</p>
<ol>
<li><code>OneToOneRel</code>类型的属性不会被添加到<code>object_data</code>中；</li>
<li>对于<code>OneToOneField</code>以及<code>ForeignKey</code>，被添加到<code>object_dict</code>中的是<code>foreign key</code>的值而不是整个关联对象。</li>
</ol>
<p>所以，<code>instance</code>中的<code>OneToOneRel</code>属性不会传递到生成Form的<code>initial</code>参数中。</p>
<p>内层ModelForm的在初始化之前应该能够从外层ModelForm的<code>instance</code>属性中获取到自身对应的<code>instance</code>。在<code>BoundModelFormField</code>中实现<code>property instance</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">instance</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># 在inner_form实例化之前，从outer_form的instance获取instance</span></div><div class="line">        <span class="comment"># 或者在ModelFormField上获取instance</span></div><div class="line">        instance = getattr(self.form.instance, self.name, <span class="keyword">None</span>) <span class="keyword">or</span> self.field.instance</div><div class="line"></div><div class="line">        <span class="keyword">return</span> instance</div></pre></td></tr></table></figure>
<p>同时，还需要重写<code>BoundModelFormField.inner_form</code>属性，在获取inner_form的时候添加进<code>instance</code>初始化参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@cached_property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_form</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.form.is_bound:</div><div class="line">            <span class="keyword">return</span> self.field.get_form(self.form.data, self.initial, self.instance)</div><div class="line">        <span class="keyword">return</span> self.field.get_form(initial=self.initial, instance=self.instance)</div></pre></td></tr></table></figure>
<h1 id="Meta-fields-exclude"><a href="#Meta-fields-exclude" class="headerlink" title="Meta.fields/exclude"></a>Meta.fields/exclude</h1><p>在ModelForm通过Meta.fields/exclude指定ModelForm中Fields的时候，同样会将范围缩小在<code>concrete_fields</code>, <code>private_fields</code>, <code>many_to_many</code>范围之内。所以在Meta.fields中指定<code>OneToOneRel</code>对象的field name就会被忽略。</p>
<p>但是通过声明的方式常见FormField的field则不会做检查，直接添加到FormField.fields属性当中。</p>
<blockquote>
<p>这一块相关内容以后再实现。因为涉及到根据model field的类型自动选择form field的类型，所以可能涉及到修改代码的部分比较多且逻辑复杂。</p>
</blockquote>
<h1 id="save-方法"><a href="#save-方法" class="headerlink" title="save()方法"></a>save()方法</h1><p>我们希望在外层ModelForm调用<code>save()</code>方法的过程中，自动调用内层ModelForm的<code>save()</code>方法并确保两者的关联关系。</p>
<p>为此，需要在Mixin中重新实现<code>ModelForm.save()</code>方法，在外层ModelForm执行<code>save()</code>的过程中，执行所有内层ModelForm的<code>save()</code>方法。</p>
<p>在文章开头的前提约定之下（即内层ModelForm的model存在<code>OneToOneField</code>指向外层ModelForm的model），为了保证内外层ModelForm对应model之间关系能够正确保存，应该先保存外层ModelForm，获取外层对象的pk值，关联内层对象后再保存内层对象。</p>
<p>这一保存逻辑只能在参数<code>commit=True</code>的情况下实现。如果<code>commit=False</code>，用户需要手动关联内外层对象（新建对象的情况下）。</p>
<p>同时，还需要保证内外层ModelForm.save()操作的原子性。</p>
<h1 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h1><p>这些坑主要是在测试的过程中遇到的，有助于提高对Django执行原理的理解：</p>
<ol>
<li><p>作为初始化参数的instance在ModelForm验证过程中会被验证通过的值修改！我在两个测试样例中用了同一个全局的instance，发现两个测试样例的结果互相耦合。一直以为是ModelFormField的实现中逻辑有错误，花了很长时间debug。。。</p>
</li>
<li><p>对于required=False的ModelForm Field，如果传入的data中没有这个Field对应的值，则在验证过程后返回Field类型对应的默认值，并将这个默认值作为<code>save()</code>方法最终返回instance对应属性的值，而不是初始化参数instance中对应属性的值。例如，一个required=False的CharField，如果传入的data为None，则验证过程中会转换成空字符串，最终save()的结果对应属性值为空字符串，而不是初始化参数instance中对应属性的值，初始化参数instance响应的属性值会被设置为空字符串。</p>
</li>
<li><p>如果在内层ModelForm的field中包含了指向外层ModelForm的field，这个field是会被传入的data值修改的。所以在<code>save(commit=True)</code>的过程中，即使将内层form的instance的关联属性指向外层form的instance，最终在内层form调用<code>save()</code>的过程中被data值覆盖掉。<br> 解决这个Bug的一个方案是：在内层ModelForm实例化的过程中，将指向外层ModelForm的Field去除掉。</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章继续记录实现ModelFormField的过程。&lt;/p&gt;
&lt;p&gt;ModelFormField继承自FormField，在FormField的基础上实现。&lt;/p&gt;
&lt;p&gt;为了简单，在这一阶段的实现当中，先做一下约定：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Model
    
    </summary>
    
      <category term="Django" scheme="https://resettingmq.github.io/categories/Django/"/>
    
    
      <category term="Django" scheme="https://resettingmq.github.io/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Django FormField 实现笔记 一</title>
    <link href="https://resettingmq.github.io/2017/07/19/django-custom-FormField/"/>
    <id>https://resettingmq.github.io/2017/07/19/django-custom-FormField/</id>
    <published>2017-07-19T01:58:54.000Z</published>
    <updated>2017-07-22T16:42:37.303Z</updated>
    
    <content type="html"><![CDATA[<p>在Web应用中对一对一关系的处理表单处理，有时需要同时将关系两端的form对象添加到同一个HTML表单中进行提交。</p>
<p>在Django中，一种常用的做法是在前端分辨渲染两个表单，然后在后端对提交数据分别进行处理并关联。</p>
<p>在这篇文章里，尝试一种新的思路：将Form包装进Field中，使其能够像普通Field一样定义在其它（外层）Form中，同时又能够提供Form操作的接口（例如渲染，验证，获取数据等）。</p>
<h1 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h1><ol>
<li><code>FormField</code>能够接受form_class参数以及initial参数，渲染这个Field的时候能够生成指定form；</li>
<li>from_class可以时ModelFrom，并能够根据instance参数指定的值初始化</li>
<li>能够接受model参数，根据指定的instance初始化表单</li>
</ol>
<h1 id="FormField-数据"><a href="#FormField-数据" class="headerlink" title="FormField 数据"></a>FormField 数据</h1><h2 id="initial-数据"><a href="#initial-数据" class="headerlink" title="initial 数据"></a><code>initial</code> 数据</h2><p>对于内层Form中的Field，<code>initial</code>数据可以有三个来源：</p>
<ol>
<li>内层Form的Field在定义时指定的<code>initial</code>值；</li>
<li>FormField在定义时指定的<code>initial</code>值；</li>
<li>外层Form在实例化时指定的<code>initial</code>值</li>
</ol>
<p>这三种数据来源的优先级依次从低到高。</p>
<p>由于Django Field类型默认实现中只是简单的在Form initial和Field initial中选择，所以需要在<code>BoundFormField</code>重新实现<code>initial()</code>来修改获取<code>initial value</code>的逻辑（弃用了<code>Form.get_initial_for_field()</code>）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># in BoundFormField class definition</span></div><div class="line"></div><div class="line"><span class="meta">@property</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">initial</span><span class="params">(self)</span>:</span></div><div class="line">    value = copy.copy(self.field.initial)</div><div class="line">    value.update(self.form.initial.get(self.name, &#123;&#125;))</div><div class="line">    </div><div class="line">    retur value</div></pre></td></tr></table></figure>
<h2 id="POST-数据"><a href="#POST-数据" class="headerlink" title="POST 数据"></a>POST 数据</h2><p>在Django应用程序响应POST请求时，将POST数据作为data初始化参数来生成Form实例。</p>
<p>为了能够避免内层Form的Field与其它Field名称冲突，同时为了便于提取数据，内层Form的Field对应HTML标签的name属性为<code>&lt;prefix&gt;-&lt;inner_field_name&gt;</code> <del><code>&lt;form_prefix&gt;-&lt;formfield_name&gt;-&lt;inner_field_name&gt;</code></del> <del><code>&lt;formfield_name&gt;-&lt;inner_field_name&gt;</code></del> 的形式。</p>
<p>这个可以通过在内层Form实例化的时候指定<code>prefix</code>参数来实现。</p>
<blockquote>
<p>注意：为了能够正确的实现Form的多层嵌套，需要加上<code>&lt;form_prefix&gt;</code>。</p>
</blockquote>
<p><code>Widget.value_from.datadict(data, files, name)</code>方法提供从data中提取数据的接口。<br>为了符合POST数据的情况，这里约定data是一个没有嵌套的（多值）字典形式。</p>
<p>由于Django Form会处理Field的名字与prefix，到传入的data字典中取响应的值，忽略data字典中其它无关的值，所以<code>Widget.value_from.datadict(data, files, name)</code>方法仅需要简单的将整个data返回，不需要做数据的过滤与修剪。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">value_from_datadict</span><span class="params">(self, data, files, name)</span>:</span></div><div class="line">    <span class="keyword">return</span> data</div></pre></td></tr></table></figure>
<h1 id="提供Django-Form的接口"><a href="#提供Django-Form的接口" class="headerlink" title="提供Django Form的接口"></a>提供Django Form的接口</h1><p>虽然FormField是一个Django Field，但我们希望它能够提供一些Django Form的行为。例如：</p>
<ol>
<li>它的字符串表示形式应该是<code>Form.as_table()</code>的形式（保证在外层<code>Form.as_table()</code>的情况下，内层的FormField能够提供一致的输出）；<br> <em>但是在外层Form调用<code>as_p()/as_ul()</code>方法时似乎无解…</em></li>
<li>能够像Django Form一样通过字典的键访问FormField所具有的Field和BoundField；</li>
<li>对FormField进行验证的时候，会调用对内层Form的验证；</li>
</ol>
<p>Django Form能够通过类属性<code>base_fields</code>(或者<code>declared_fields</code>)访问Form定义时声明的Field实例，而如果外层Form没有实例化的情况下，应该不能够访问内嵌Form实例对象的属性的。<br>所以就要求FormField所包含的内层Form延迟实例化。</p>
<p>内层Form实例化的时机也有讲究，必须发生在外层Form实例化之后，对内层Form实例属性进行访问之前。</p>
<p>由于Django Form进行渲染或者取值是对<code>BoundField</code>对象进行；<br>同时，Django对Form实例的迭代以及通过下标取值返回的也是BoundField对象，所以对内层Form实例的访问的逻辑应该在<code>BoundField</code>对象中实现。</p>
<p>所以考虑实现一个BoundField的子类，实现对内层Form实例访问的接口；同时在BoundField子类中增加一个<code>cached_property</code>，这样也能保证内层Form实例化的延迟。</p>
<p>当外层Form为unbound时（初始化参数data为None），生成的内层Form也应该为unbound，这样才能保证内层Form的initial值能够正常渲染（原因是<code>BoundField.value()</code>的默认实现会在bound的情况下使用<code>BoundField.data</code>渲染，而不是<code>BoundField.initial</code>，除非该<code>field.disabled==True</code>）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundFormField</span><span class="params">(BoundField)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, name)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.inner_form[name]</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> iter(self.inner_form)</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">data</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># 委托到inner form各field上取值</span></div><div class="line">        <span class="comment"># 对于多层嵌套的FormField实现了递归取值</span></div><div class="line">        <span class="comment"># 而不需要在POST数据中根据键来构建dict（需要实现递归逻辑）</span></div><div class="line">        <span class="keyword">return</span> &#123;name: self.inner_form[name].data <span class="keyword">for</span> name <span class="keyword">in</span> self.inner_form.fields&#125;</div><div class="line"></div><div class="line"><span class="meta">    @cached_property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_form</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># 加入form.prefix是为了实现多成嵌套</span></div><div class="line">        <span class="keyword">if</span> self.form.is_bound:</div><div class="line">            <span class="keyword">return</span> self.field.get_form(self.form.data, self.initial)</div><div class="line">        <span class="keyword">return</span> self.field.get_form(initial=self.initial)</div><div class="line"></div><div class="line">    <span class="comment"># some other code ...</span></div></pre></td></tr></table></figure>
<h1 id="FormField上参数的处理"><a href="#FormField上参数的处理" class="headerlink" title="FormField上参数的处理"></a>FormField上参数的处理</h1><h2 id="1-required"><a href="#1-required" class="headerlink" title="1. required"></a>1. <code>required</code></h2><p>当在FormField上<code>required</code>为True时，内层Form的Field保持自身的<code>required</code>状态；为False时，整个内层Form可以为空，这个时候Form返回的值为<code>{}</code>(空dict)；</p>
<blockquote>
<p><del><em>注意：这里要求返回空dict。因为内层Form的生成依赖于<code>BoundFormField.data property</code>，如果这种情况下这个<code>property</code>返回<code>None</code>的话，则生成的内层From实例是<code>unbound</code>，再次渲染的时候会显示有<code>initial</code>的值</em></del></p>
<p><em>（因为对内层Form是否Bound的控制改在了<code>BoundFieldForm.inner_form property</code>中实现，所以这里不再有要求）</em></p>
</blockquote>
<p>Field的<code>use_required_attribute</code>参数只能控制表单渲染时不添加<code>required</code> HTML属性，不能改变Form在验证时对<code>required</code>的处理。</p>
<p>所以在FormField的<code>required</code>属性为False时，需要将内层Form所有的field的<code>required</code>属性设置为<code>False</code>。这在<code>FormField.gett_form()</code>中实现。</p>
<h2 id="2-disabled"><a href="#2-disabled" class="headerlink" title="2. disabled"></a>2. <code>disabled</code></h2><p>如果FormField上<code>disabled</code>为True时，内层Form所有Field为<code>disabled</code>状态，渲染以及验证的数据由<code>initial</code>的值决定；当为False时，内层Form各Field的<code>disabled</code>状态由自身决定。</p>
<p>同样，如果在<code>FormField.disabled == True</code>的情况下，应该将内层Form所有field的<code>disabled</code>属性设置为<code>True</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_form</span><span class="params">(self, data=None, initial=None, **kwargs)</span>:</span></div><div class="line">    kwargs[<span class="string">'data'</span>] = data</div><div class="line">    kwargs[<span class="string">'initial'</span>] = initial</div><div class="line">    kwargs[<span class="string">'prefix'</span>] = self.prefix</div><div class="line"></div><div class="line">    form = self.form_class(**kwargs)</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.required:</div><div class="line">        <span class="keyword">for</span> field <span class="keyword">in</span> form.fields.values():</div><div class="line">            field.required = <span class="keyword">False</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> self.disabled:</div><div class="line">        <span class="keyword">for</span> field <span class="keyword">in</span> form.fields.values():</div><div class="line">            field.disabled = <span class="keyword">True</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> form</div></pre></td></tr></table></figure>
<h1 id="FormField验证"><a href="#FormField验证" class="headerlink" title="FormField验证"></a>FormField验证</h1><p>同样，FormField的验证也委托到内层Form的验证，在<code>FormField.clean()</code>中实现：</p>
<ol>
<li>如果内层Form验证通过，则返回内层Form的<code>cleaned_data</code>；</li>
<li>如果内层Form验证不通过，则根据内层Form的erros属性构造<code>ValidationError</code>，并抛出；</li>
</ol>
<p>因为验证的数据是dict（一般情况为<code>POST</code>数据），所以需要根据这个dict生成内层form实例，并将内层form实例验证生成的<code>cleaned_data</code>作为新的验证目标数据value返回。这部分逻辑在<code>FormField.to_python()</code>中实现。</p>
<p>有一个比较重要的问题是Django的验证过程中，没有将Field的name传入到<code>Field.clean()</code>中，所以没有办法为内层form实例指定正确的prefix。除非重写<code>Form._clean_fields()</code>，除此之外没有找到什么其它的办法。</p>
<p>所以退而求其次，在<code>FormField</code>初始化参数中加入prefix参数，手动指定。这样就能够在<code>to_python()</code>方法中生成正确的内层Form实例。</p>
<p><code>validate()</code>中实现<code>required</code>验证，可以直接利用默认实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_python</span><span class="params">(self, value)</span>:</span></div><div class="line">    form = self.get_form(value)</div><div class="line">    <span class="keyword">if</span> form.is_valid():</div><div class="line">        <span class="keyword">return</span> form.cleaned_data</div><div class="line"></div><div class="line">    <span class="comment"># 将inner_form的errors转化为不带error_dict属性的ValidationError对象</span></div><div class="line">    new_error_list = []</div><div class="line">    <span class="keyword">for</span> name, error_list <span class="keyword">in</span> form.errors.as_data().items():</div><div class="line">        <span class="keyword">for</span> error <span class="keyword">in</span> error_list:</div><div class="line">            <span class="keyword">if</span> hasattr(error, <span class="string">'message'</span>):</div><div class="line">                error.message = <span class="string">'Field &#123;&#125; in FormField: &#123;&#125;'</span>.format(name, error.message)</div><div class="line">        new_error_list.extend(error_list)</div><div class="line">    <span class="keyword">raise</span> ValidationError(new_error_list, code=<span class="string">'FormFieldError'</span>)</div></pre></td></tr></table></figure>
<h1 id="HTML代码生成"><a href="#HTML代码生成" class="headerlink" title="HTML代码生成"></a>HTML代码生成</h1><p>在Django中，<code>Widget</code>主要负责根据表单项生成HTML以及从<code>POST</code>的数据中提取相关表单项的数据。</p>
<p>生成HTML代码主要在<code>Widget.render(name, value, attrs, form)</code>方法中实现。<br><code>Widget.render()</code>方法中的value参数包含了需要渲染的数据，在这个例子中，它是一个<code>form</code>的实例。</p>
<p>前面已经提到，将FormField字符串化（即在模板中直接输出FormField实例<em>（对应的UnboundField）</em>）的结果设计成调用内层Form的<code>as_table()</code>方法，所以只需要在<code>Widget.render()</code>方法中返回<code>value.as_table()</code>即可（下面会介绍一个小扩展，可以通过自定义template修改输出的FormField）。</p>
<h2 id="稍微扩展一下"><a href="#稍微扩展一下" class="headerlink" title="稍微扩展一下"></a>稍微扩展一下</h2><p>直接输出FormField内层Form的table形式，往往不是我们需要的，而通过内层Form的属性单独控制各个Field的输出，有比较繁琐。</p>
<p>为了减少重复工作，便于样式化修改，考虑利用template格式化FormField。</p>
<p><code>Django Widget</code>的渲染可以由模板控制，模板的路径在<code>Widget.template_name</code>中设置。</p>
<p><code>Widget.render()</code>方法会调用<code>Widget._render()</code>方法，这个方法能够根据指定的template，生成HTML代码段。</p>
<p><code>Widget.render()</code>方法会调用<code>Widget.get_context()</code>方法，生成渲染field对应HTML代码所需要的上下文。<br>因为默认实现中，生成上下文的过程中会自动将value转化为字符串形式，这不是我们想要的结果，所以我们还需要重写<code>Widget.get_context()</code>方法。</p>
<p>为了能够方便的控制模板的渲染，在FormField的初始化参数中增加了<code>using_template</code>和<code>template_name</code>参数。当<code>using_template == True</code>时，使用模板渲染FormField（而不是简单的<code>as_table()</code>)；<code>template_name</code>用于指定模板路径，用于覆盖Widget设置的默认模板路径。</p>
<p>同时还需要重写<code>BoundFormField.as_widget()</code>方法，在它调用<code>Widget.render()</code>方法的时候将<code>using_template</code>和<code>template_name</code>传入。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% for field in form %&#125;</div><div class="line">    &#123;&#123; field &#125;&#125;</div><div class="line">&#123;% endfor %&#125;</div></pre></td></tr></table></figure>
<p>通过修改这个模板，我们可以对<code>FormField</code>输出的HTML样式进行控制。</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ol>
<li><code>ModelFormField</code>相关的实现，在下篇文章记录。</li>
<li><code>Field</code>,<code>BoundField</code>, <code>Widget</code>中有很多方法都没有考虑以及测试，在调用这些方法的时候有可能会异常。</li>
<li>在这个实现中，没有考虑与<code>FileField</code>等Field类型的情况，今后学习了有关表单文件处理的代码之后再慢慢完善。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Web应用中对一对一关系的处理表单处理，有时需要同时将关系两端的form对象添加到同一个HTML表单中进行提交。&lt;/p&gt;
&lt;p&gt;在Django中，一种常用的做法是在前端分辨渲染两个表单，然后在后端对提交数据分别进行处理并关联。&lt;/p&gt;
&lt;p&gt;在这篇文章里，尝试一种新的思路
    
    </summary>
    
      <category term="Django" scheme="https://resettingmq.github.io/categories/Django/"/>
    
    
      <category term="Django" scheme="https://resettingmq.github.io/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>custom_django_admin_command</title>
    <link href="https://resettingmq.github.io/2017/07/14/custom-django-admin-command/"/>
    <id>https://resettingmq.github.io/2017/07/14/custom-django-admin-command/</id>
    <published>2017-07-14T15:25:01.000Z</published>
    <updated>2017-07-15T09:04:42.818Z</updated>
    
    <content type="html"><![CDATA[<p>最近在将Django编写的应用部署到其它服务器上的时候，需要生成DB中的演示数据。由于演示数据生成函数需要在Model上逐个调用；同时Model之前存在依赖关系（<code>One-to-One</code>, <code>One-to-Many</code>等关系），对数据生成函数的调用顺序也有要求，所以手动完成比较麻烦且容易出错。</p>
<p>这里考虑使用Django的自定义admin command来自动化这一操作。</p>
<p>要实现这一功能，主要涉及两个要点：</p>
<ol>
<li>实现自定义<code>admin command</code>;</li>
<li>解决Model之间的依赖关系</li>
</ol>
<p><em>Note: 以下所有的讨论都不包括<code>Many-to-Many</code>关系。多对多的关系有一些特殊情况要处理，以后再做讨论</em></p>
<h2 id="1-自定义admin-command"><a href="#1-自定义admin-command" class="headerlink" title="1. 自定义admin command"></a>1. 自定义<code>admin command</code></h2><p>Django中的<code>admin command</code>指的是通过<code>django-admin</code>/<code>manage.py</code>/<code>python -m django</code>提供的参数化调用接口。</p>
<p>跟Flask通过装饰器注册command的方式不同，Django规范了command定义的目录结构以及继承结构：</p>
<ol>
<li>Django自动搜索已注册的app，将<code>app.management.commands</code>包下的所有不以下划线作为名字开头的模块自动注册为command；</li>
<li>所有的command的模块中必须定义名为Command类，并且这个类必须继承自<code>django.core.management.BaseCommand</code>类或者其子类。</li>
</ol>
<h3 id="1-1-设计目标"><a href="#1-1-设计目标" class="headerlink" title="1.1 设计目标"></a>1.1 设计目标</h3><ol>
<li>command名为init_db；</li>
<li>command的调用参数为 <code>django-admin init_db [app_label] [model_name]</code>：<ul>
<li>如果不指定app_label,则对所有app的所有model执行数据生成；</li>
<li>如果指定app_label不指定model_name，则对该app的所有model执行数据生成；</li>
<li>如果同时指定了app_label和model_name，则只对该app的指定model执行数据生成。</li>
</ul>
</li>
</ol>
<h3 id="1-2-command-argument"><a href="#1-2-command-argument" class="headerlink" title="1.2 command argument"></a>1.2 command argument</h3><p>Django admin command使用了<code>argparse</code>库来实现。所以定义参数的方式同<code>argparse</code>一样。</p>
<p><code>BaseCommand</code>的<code>add_arguments()</code>方法提供了注册参数的入。这个函数提供了一个<code>parser</code>参数，作为<code>argparse.ArgumentPaser</code>实例。<br>所以只需要调用<code>parser.add_argument()</code>就能够注册参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_arguments</span><span class="params">(self, parser)</span>:</span></div><div class="line">    parser.add_argument(<span class="string">'app_label'</span>, action=<span class="string">'store'</span>, nargs=<span class="string">'?'</span>)</div><div class="line">    parser.add_argument(<span class="string">'model_name'</span>, action=<span class="string">'store'</span>, nargs=<span class="string">'?'</span>)</div></pre></td></tr></table></figure>
<h3 id="1-3-业务逻辑"><a href="#1-3-业务逻辑" class="headerlink" title="1.3 业务逻辑"></a>1.3 业务逻辑</h3><p>所有的业务逻辑都在<code>BaseCommand.handle()</code>函数中实现。</p>
<p>这个函数提供了一个<code>options</code>字典，这个字典包含了获取的所有command参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self, *args, **options)</span>:</span></div><div class="line">    all_models = apps.get_models()</div><div class="line"></div><div class="line">    <span class="keyword">if</span> options[<span class="string">'app_label'</span>] <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        target_models = all_models</div><div class="line">        initialized = []</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            target_app = apps.get_app_config(options[<span class="string">'app_label'</span>])</div><div class="line">        <span class="keyword">except</span> LookupError <span class="keyword">as</span> e:</div><div class="line">            <span class="keyword">raise</span> CommandError(<span class="string">'app &#123;&#125; not found'</span>.format(options[<span class="string">'app_label'</span>]))</div><div class="line">        <span class="keyword">if</span> options[<span class="string">'model_name'</span>] <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            target_models = target_app.get_models()</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">try</span>:</div><div class="line">                target_models = [target_app.get_model(options[<span class="string">'model_name'</span>]), ]</div><div class="line">            <span class="keyword">except</span> LookupError:</div><div class="line">                <span class="keyword">raise</span> CommandError(<span class="string">'model &#123;&#125; not found'</span>.format(options[<span class="string">'model_name'</span>]))</div><div class="line">        <span class="comment"># 需要将iterator转为list</span></div><div class="line">        <span class="comment"># 因为not in操作有可能提前将iterator耗尽</span></div><div class="line">        target_models = list(target_models)</div><div class="line">        initialized = [m <span class="keyword">for</span> m <span class="keyword">in</span> all_models <span class="keyword">if</span> m <span class="keyword">not</span> <span class="keyword">in</span> target_models]</div><div class="line">    init_target = [[m, <span class="keyword">False</span>, _get_dependent_models(m)] <span class="keyword">for</span> m <span class="keyword">in</span> target_models]</div><div class="line"></div><div class="line">    init_target_len = len(init_target)</div><div class="line">    count = <span class="number">0</span></div><div class="line">    <span class="keyword">while</span> init_target_len &gt; count:</div><div class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> init_target:</div><div class="line">            <span class="keyword">if</span> m[<span class="number">1</span>]:</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            <span class="keyword">if</span> _check_all_dependent_model_initialized(m[<span class="number">2</span>], initialized):</div><div class="line">                initialized.append(m[<span class="number">0</span>])</div><div class="line">                <span class="comment"># 生成数据</span></div><div class="line">                _populate_model(m[<span class="number">0</span>])</div><div class="line">                m[<span class="number">1</span>] = <span class="keyword">True</span></div><div class="line">                count += <span class="number">1</span></div></pre></td></tr></table></figure>
<p>一些辅助函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_dependent_models</span><span class="params">(model)</span>:</span></div><div class="line">    <span class="keyword">return</span> [f.related_model <span class="keyword">for</span> f <span class="keyword">in</span> model._meta.get_fields()</div><div class="line">            <span class="keyword">if</span> f.related_model != model <span class="keyword">and</span> (f.one_to_one <span class="keyword">or</span> f.many_to_one) <span class="keyword">and</span> f.concrete]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_populate_model</span><span class="params">(model)</span>:</span></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        model.populate()</div><div class="line">    <span class="keyword">except</span> AttributeError:</div><div class="line">        logging.warning(<span class="string">'model &#123;&#125; does not support populate()'</span></div><div class="line">                        .format(model._meta.verbose_name))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_check_all_dependent_model_initialized</span><span class="params">(dependencies, initialized)</span>:</span></div><div class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> dependencies:</div><div class="line">        <span class="keyword">if</span> d <span class="keyword">not</span> <span class="keyword">in</span> initialized:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure></p>
<h3 id="1-4-抛出异常"><a href="#1-4-抛出异常" class="headerlink" title="1.4 抛出异常"></a>1.4 抛出异常</h3><p>如果app_label/model_name指定错误，则抛出<code>django.core.management.base.CommandError</code>异常。<br>使用这个异常类，能够在命令行中格式化输出错误信息。</p>
<h3 id="1-5-测试"><a href="#1-5-测试" class="headerlink" title="1.5 测试"></a>1.5 测试</h3><p>Django提供了<code>django.core.management.call_command</code>测试接口。</p>
<p>通过这个接口，可以在测试用例中调用自定义<code>admin command</code>实现测试。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">InitDbCommandTestCase</span><span class="params">(TransactionTestCase)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_initdb_command_registered</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># 测试command是否注册成功</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_accept_app_label_positional_argument</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># 测试app_label参数是否设置成功</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_app_label_argument_is_optional</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># 测试app_label参数是否可选</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_raise_command_error_when_app_label_not_found</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># 测试app_label错误是否引发异常</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_accept_model_name_positional_argument</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># 测试是否接受model_name参数</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_raise_command_error_when_model_name_not_found</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># 测试model_name参数错误是否抛出异常</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_properly_polulate_data_without_app_label</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># 测试不设置app_label的情况下生成数据是否正确</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_properly_polulate_data_with_only_app_label</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># 测试仅设置app_label参数的情况下是否正确生成数据</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_properly_populate_data_with_app_label_and_model_name</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># 测试同时设置app_label和model_name的情况下是否正确生成数据</span></div></pre></td></tr></table></figure>
<h2 id="2-Model之间的依赖关系"><a href="#2-Model之间的依赖关系" class="headerlink" title="2. Model之间的依赖关系"></a>2. Model之间的依赖关系</h2><p>Model之间的依赖关系形成了一个森林，但由于学的数据结构全部还给老师了，不知道是否有比较可靠的遍历森林节点的方法。<br>所以这里尝试使用一直比较笨拙的方法来遍历Model。</p>
<p>基本的思路是：</p>
<ol>
<li>获取所有的目标Model（即要生成数据的Model);</li>
<li>获取目标Model所有依赖的Model，生成一个list；</li>
<li>生成字典<code>init_target</code>，key为Model名，value为依赖Model组成的list；</li>
<li>维护一个Model集合<code>initialized</code>，用来表示以及完成数据生成的Model；</li>
<li>将所有目标外的Model添加进<code>initialized</code>集合（默认不需要生成数据的Model以及有可用数据）；</li>
<li>遍历<code>init_target</code>，如果这个Model的依赖都在<code>initialized</code>中，则完成这个Model的数据生成，并将这个Model从<code>init_target</code>去除，加入到<code>initialized</code>中；</li>
<li>重复步骤6，直到<code>init_target</code>为空。</li>
</ol>
<h2 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h2><p>花了比估计要多的时间才完成这个小功能，主要是遇到了几个坑，希望之后能注意：</p>
<ol>
<li><p><code>Recursive relation</code>。在项目的model中存在到自己的外键。在最开始的实现中没有考虑到这一点，所以就形成了某个model依赖于自身，在生成数据的时候，导致无限循环；</p>
</li>
<li><p><code>Transaction</code>。主要是在编写测试的过程中遇到了这样一个问题。Django的TestCase类会将每个测试用例封装在一个transaction中，所以一旦测试用例中产生database相关的异常，这个测试用例对数据库所有的操作都会被回滚。由于回滚后就不存在transaction环境，所以即便是在代码中对异常进行了处理，产生异常之后的对数据库的query都会抛出<code>TransactionManagementError</code>异常。解决的方式是换用<code>TransactionTestCase</code>。</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在将Django编写的应用部署到其它服务器上的时候，需要生成DB中的演示数据。由于演示数据生成函数需要在Model上逐个调用；同时Model之前存在依赖关系（&lt;code&gt;One-to-One&lt;/code&gt;, &lt;code&gt;One-to-Many&lt;/code&gt;等关系），对数
    
    </summary>
    
      <category term="Django" scheme="https://resettingmq.github.io/categories/Django/"/>
    
    
      <category term="Django" scheme="https://resettingmq.github.io/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>DataTables utils 开发笔记 - 给数据行添加单击事件处理</title>
    <link href="https://resettingmq.github.io/2017/07/09/datatables-utils-add-row-click/"/>
    <id>https://resettingmq.github.io/2017/07/09/datatables-utils-add-row-click/</id>
    <published>2017-07-09T00:59:15.000Z</published>
    <updated>2017-07-09T16:16:13.832Z</updated>
    
    <content type="html"><![CDATA[<p>有一个常用的场景：用户在DataTables所展示的数据行的某个地方单击，会发送请求到server请求数据行对应数据的详细信息。要实现这个需求，就需要我们对DataTables渲染得到的表格添加单击事件处理。</p>
<h2 id="关于pk值的指定以及渲染"><a href="#关于pk值的指定以及渲染" class="headerlink" title="关于pk值的指定以及渲染"></a>关于pk值的指定以及渲染</h2><p>我们还需要在DataTables渲染的数据项中增加数据对应的pk值，使得在发送请求时，能够指定唯一对应的数据项。</p>
<p>具体的设计目标：</p>
<ol>
<li><p>pk键的名称使用<code>dt_rowId</code>作为名称在<code>ModelDataTables</code>的子类中的类属性指定；如果没有指定的情况下，默认为<code>pk</code>；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># utils/utils.py</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelDataTable</span><span class="params">(metaclass=ModelDataTableMetaClass)</span>:</span></div><div class="line">    dt_rowId = <span class="string">'pk'</span></div><div class="line">    <span class="comment"># ... some other code ...</span></div></pre></td></tr></table></figure>
</li>
<li><p>根据<code>dt_rowId</code>的值自动在<code>ModelDataTables</code>的子类中添加一个<code>DataTablesColumn</code>对象，并于对应的model field相关联；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># utils/utils.py</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelDataTableMetaClass</span><span class="params">(type)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(mcls, name, bases, attrs)</span>:</span></div><div class="line">        <span class="comment"># ... some code ...</span></div><div class="line">        <span class="keyword">for</span> name, value <span class="keyword">in</span> atttrs.items():</div><div class="line">            <span class="keyword">if</span> name.startswith(<span class="string">'dt_'</span>):</div><div class="line">                attr_name = name.split(<span class="string">'dt_'</span>, <span class="number">1</span>)[<span class="number">1</span>]</div><div class="line">                <span class="keyword">if</span> attr_name == <span class="string">'rowId'</span> <span class="keyword">and</span> value <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">                    <span class="comment"># ... some type-check code ...</span></div><div class="line">                    <span class="keyword">if</span> value == <span class="string">'pk'</span>:</div><div class="line">                        pk_field = _get_field(model, <span class="string">'id'</span>)</div><div class="line">                    <span class="keyword">else</span>:</div><div class="line">                        pk_field = _get_field(model, value)</div><div class="line">                    <span class="keyword">if</span> pk_field <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">                        pk_column = DataTablesColumn.get_instance_from_field(pk_field)</div><div class="line">                        pk_column.name = value</div><div class="line">                        d[<span class="string">'pk_column'</span>] = pk_column</div><div class="line">        <span class="comment"># ... some other code ...</span></div></pre></td></tr></table></figure>
</li>
<li><p>返回的数据中包含pk键值对；但是返回的HTML table header中不包含pk的列。</p>
</li>
</ol>
<h2 id="Javascript的生成"><a href="#Javascript的生成" class="headerlink" title="Javascript的生成"></a>Javascript的生成</h2><p>除了在DataTables实例中加入了pk信息，还需要在前端的Javascript代码中添加单击列的事件。最直观的方便便是通过jQuery语法对<code>tr</code>DOM元素添加事件处理程序。在该事件处理函数中，获取对应行的pk信息，并对指定URL发起请求。</p>
<p>pk值可以通过DataTables row对象的id()方法获取；<br>URL请求的URL可以在<code>ModelDataTable.Meta.detail_url_format</code>中指定（该参数的介绍，请参见<a href="/2017/07/06/datatabels-utils">之前文章</a>）。</p>
<p>在没有设置<code>ModelDataTable.Meta.detail_url_format</code>的情况下，<code>render_js_script</code>自定义模板标签的输出中就不会包含注册<code>tr</code>元素单击事件的代码。在模板标签的代码中，这是通过<code>ModelDataTable.handle_row_click</code>属性来判断的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># utils/utils.py</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelDataTableMetaClass</span><span class="params">(type)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(mcls, name, bases, attrs)</span>:</span></div><div class="line">        <span class="comment"># ... some code ...</span></div><div class="line">        meta = attrs.get(<span class="string">'Meta'</span>)</div><div class="line">        detail_url_format = getattr(meta, <span class="string">'detail_url_format'</span>, <span class="keyword">None</span>)</div><div class="line">        <span class="keyword">if</span> detail_url_format <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            d[<span class="string">'handle_row_click'</span>] = <span class="keyword">False</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> isinstance(detail_url_format, str)</div><div class="line">                <span class="keyword">raise</span> ImproperlyConfigured(<span class="string">'Some error message...'</span>)</div><div class="line">            d[<span class="string">'handle_row_click'</span>] = <span class="keyword">True</span></div><div class="line">            d[<span class="string">'detail_url_format'</span>] = detail_url_format</div><div class="line">        <span class="comment"># ... some other code ...</span></div></pre></td></tr></table></figure>
<p>模板标签部分大致的实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># utils/templatetags/datatables_widget.py</span></div><div class="line"></div><div class="line"><span class="comment"># ... some code ...</span></div><div class="line"></div><div class="line"><span class="meta">@register.inclusion_tag('dt_template/dt_jsscript.html')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">render_js_script</span><span class="params">(dt_config)</span>:</span></div><div class="line">    <span class="keyword">return</span> &#123;<span class="string">'dt_config'</span>: dt_config&#125;</div><div class="line"></div><div class="line"><span class="meta">@register.simple_tag(takes_context=True)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">detail_url</span><span class="params">(context, id_identifier)</span>:</span></div><div class="line">    detail_url_format = context[<span class="string">'dt_config'</span>].detail_url_format</div><div class="line">    tokens = detail_url_format.split(<span class="string">'&#123;&#125;'</span>)</div><div class="line">    tokens = [<span class="string">'"&#123;&#125;"'</span>.format(token) <span class="keyword">for</span> token <span class="keyword">in</span> tokens]</div><div class="line">    tokens.insert(<span class="number">1</span>, id_identifier)</div><div class="line">    <span class="keyword">return</span> mark_safe(<span class="string">' + '</span>.join(tokens))</div></pre></td></tr></table></figure>
<p>应用的template tags 模板<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&#123;% load datatables_widget %&#125;</div><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line">    $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> dt_inst = $(<span class="string">"#&#123;&#123; dt_config.table_id &#125;&#125;"</span>).DataTable(</div><div class="line">            &#123;&#123; dt_config.get_dt_config &#125;&#125;</div><div class="line">        );</div><div class="line"></div><div class="line">        &#123;% <span class="keyword">if</span> dt_config.handle_row_clikc %&#125;</div><div class="line">        dt_inst.on(<span class="string">'click'</span>, <span class="string">'tbody tr'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="keyword">var</span> row_id = dt_inst.row(<span class="keyword">this</span>).id();</div><div class="line">            <span class="built_in">window</span>.location.href = &#123;% detail_url <span class="string">"row_id"</span> %&#125;;</div><div class="line">        &#125;);</div><div class="line">        &#123;% endif %&#125;</div><div class="line">    &#125;);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>最后实现的<code>detail_url</code> template tag实现将保存<code>row_id</code>的<strong><em>变量名</em></strong>嵌入到<code>detail_url_format</code>中，生成Javascript代码。因为传入的时变量名字符串，使用起来有些别扭</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一个常用的场景：用户在DataTables所展示的数据行的某个地方单击，会发送请求到server请求数据行对应数据的详细信息。要实现这个需求，就需要我们对DataTables渲染得到的表格添加单击事件处理。&lt;/p&gt;
&lt;h2 id=&quot;关于pk值的指定以及渲染&quot;&gt;&lt;a hre
    
    </summary>
    
      <category term="Django" scheme="https://resettingmq.github.io/categories/Django/"/>
    
    
      <category term="Django" scheme="https://resettingmq.github.io/tags/Django/"/>
    
      <category term="DataTables" scheme="https://resettingmq.github.io/tags/DataTables/"/>
    
  </entry>
  
  <entry>
    <title>在Django-DataTables utils中添加搜索、排序、分页等功能</title>
    <link href="https://resettingmq.github.io/2017/07/07/datatables-utils-searchable-orderable/"/>
    <id>https://resettingmq.github.io/2017/07/07/datatables-utils-searchable-orderable/</id>
    <published>2017-07-07T06:34:53.000Z</published>
    <updated>2017-07-08T13:25:24.763Z</updated>
    
    <content type="html"><![CDATA[<p>在前面的文章中提到了Django-DataTables utils关于搜索和排序的设计目标。</p>
<p>当DataTables运行在非<code>serverSide</code>模式下时，搜索、排序以及分页由DataTables在前端实现，后端代码不需要负责业务处理。但是当DataTables为<code>serverSide</code>方式时，所有的查询业务都发送至后端处理。</p>
<p>为了应对这种情况，需要在后端模块中加入相应的逻辑。</p>
<h2 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h2><p>当<code>DataTables</code>工作于<code>serverSide</code>方式下时，会通过url query参数传递相关的搜索以及排序信息。后台获取这些信息，处理数据，再将数据转换成JSON返回。</p>
<h2 id="分页功能"><a href="#分页功能" class="headerlink" title="分页功能"></a>分页功能</h2><p>在<code>serverSide</code>模式下，DataTables通过<code>start</code>以及<code>length</code>请求参数指定请求的数据范围。其中<code>start</code>指定开始的数据项的下标（从0开始计数），<code>length</code>指定请求数据的长度。</p>
<p>由于Django <code>MultipleObjectsMixin</code>中的分页功能基于<code>django.core.paginator</code>，而这个Django内建的<code>paginator</code>是通过数据页的编号来指定分页数据的。为了与<code>DataTables</code>的请求参数相匹配，并没有使用这个内建的<code>paginator</code>。</p>
<p>实现的逻辑很简单，在<code>DataTablesMixin.get_json_context_data()</code>这个方法中，对进过搜索、排序后的结果进行截取即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataTablesMixin</span><span class="params">(JsonResponseMixin, JsonContextMixin)</span>:</span></div><div class="line"></div><div class="line">    <span class="comment"># ... some code ...</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_json_context_data</span><span class="params">(self, http_queryset=None)</span>:</span></div><div class="line"></div><div class="line">        <span class="comment"># ... some code ...</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前面的文章中提到了Django-DataTables utils关于搜索和排序的设计目标。&lt;/p&gt;
&lt;p&gt;当DataTables运行在非&lt;code&gt;serverSide&lt;/code&gt;模式下时，搜索、排序以及分页由DataTables在前端实现，后端代码不需要负责业务处理。
    
    </summary>
    
      <category term="Django" scheme="https://resettingmq.github.io/categories/Django/"/>
    
    
      <category term="Django" scheme="https://resettingmq.github.io/tags/Django/"/>
    
      <category term="DataTables" scheme="https://resettingmq.github.io/tags/DataTables/"/>
    
  </entry>
  
  <entry>
    <title>template_tags</title>
    <link href="https://resettingmq.github.io/2017/07/06/template-tags/"/>
    <id>https://resettingmq.github.io/2017/07/06/template-tags/</id>
    <published>2017-07-06T06:15:53.000Z</published>
    <updated>2017-07-06T14:25:53.832Z</updated>
    
    <content type="html"><![CDATA[<p>除了DataTables相关的后台部分，还需要将完成DataTables在template中相关的渲染：例如HTML table元素以及javascript代码。</p>
<p>在这里通过自定义Django template tags来实现在template中输出相关的信息。</p>
<p>在上一篇文章介绍的DataTables Utils中，通过<code>ModelDataTables</code>可以获取所有DataTables在模板中渲染所需要信息，例如table_id，数据表的表头，以及DataTables初始化代码中的参数等等。</p>
<p>所以，我们只需要在自定义template tags中引入<code>ModelDataTables</code>相关的context，渲染自定义template tags相关的模板即可。</p>
<h2 id="HTML-table元素"><a href="#HTML-table元素" class="headerlink" title="HTML table元素"></a>HTML table元素</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@register.inclusion_tag('dt_templates/dt_tabel.html')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">render_table</span><span class="params">(dt_config)</span>:</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;除了DataTables相关的后台部分，还需要将完成DataTables在template中相关的渲染：例如HTML table元素以及javascript代码。&lt;/p&gt;
&lt;p&gt;在这里通过自定义Django template tags来实现在template中输出相关的信息
    
    </summary>
    
      <category term="Django" scheme="https://resettingmq.github.io/categories/Django/"/>
    
    
      <category term="Django" scheme="https://resettingmq.github.io/tags/Django/"/>
    
      <category term="DataTables" scheme="https://resettingmq.github.io/tags/DataTables/"/>
    
      <category term="template" scheme="https://resettingmq.github.io/tags/template/"/>
    
  </entry>
  
  <entry>
    <title>datatabels_utils 开发笔记 - 整体架构</title>
    <link href="https://resettingmq.github.io/2017/07/06/datatabels-utils/"/>
    <id>https://resettingmq.github.io/2017/07/06/datatabels-utils/</id>
    <published>2017-07-06T02:11:51.000Z</published>
    <updated>2017-07-09T16:16:41.027Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目标功能"><a href="#目标功能" class="headerlink" title="目标功能"></a>目标功能</h2><ol>
<li>通过ModelDataTables类定义，设置DataTables所需要的meta信息；</li>
<li>通过template tags，能够在template中输出HTML table表头；</li>
<li>通过template tags，能够在template中生成javascript代码段；</li>
</ol>
<h2 id="ModelDataTables类"><a href="#ModelDataTables类" class="headerlink" title="ModelDataTables类"></a>ModelDataTables类</h2><p>类似于<code>Django</code>的<code>ModelForm</code>，<code>ModelDataTables</code>能够：</p>
<ol>
<li>通过<code>Meta</code>类的定义，从<code>model</code>中自动生成所需要的<code>DataTables column</code>信息；</li>
<li>在该类的子类中，能够声明式的建立<code>DataTables column</code>信息；</li>
</ol>
<p><code>DataTables column</code>信息对应<code>DataTables</code>的<code>columns</code>配置项。其它的配置项（例如<code>serverSide</code>, <code>ajax</code>等）通过类属性的方式定义。</p>
<p>为了避免与其它类属性产生混淆，约定这些类属性以<code>dt_</code>为前缀。</p>
<p>为了能够在template中生成对<code>DataTables</code>的初始化配置数据，还需要能够将这些配置数据以正确的结构构建成<code>dict</code>形式，方便在模板中输出。</p>
<p>由于<code>Django</code>没有提供内建的<code>JSON filter</code>，所以还需要实现这个<code>filter</code>（具体的实现在下一篇文章中提出）。（当然也可以在这个类中实现方法，将配置<code>dict</code>序列化成<code>JSON</code>字符串后再在template中直接输出。</p>
<p><code>Meta class</code>中的属性：</p>
<ul>
<li>model（必须要定义）</li>
<li>column_order</li>
<li>fields</li>
<li>detail_url_format<br>  这个值是一个接受一个位置格式化参数的字符串。如果没有指定这个值，则前端输出的代码不会自动添加对于DataTables行的单击处理事件；如果指定了这个值，就会在前端javascript代码中添加DataTables行的单击处理事件（需要通过template tags输出），并且在单击行时，会发送请求到这个值指定的url。</li>
</ul>
<p>可以通过元类来实现这些功能。</p>
<h3 id="ModelDataTablesMetaClass"><a href="#ModelDataTablesMetaClass" class="headerlink" title="ModelDataTablesMetaClass"></a>ModelDataTablesMetaClass</h3><p>这个类作为<code>ModelDataTables</code>的元类。<br>通过这个元类，<br>能够检查<code>Meta class</code>以及定义在其中的<code>model</code>等属性；<br>能够处理<code>ModelDataTables</code>子类中声明的<code>ModelDataTablesColumn</code>类型的属性，将其作为配置数据；<br>能够保持<code>ModelDataTables</code>子类中声明属性的顺序；<br>为<code>ModelDataTables</code>的子类在声明时生成一个包含随机数的id；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelDataTablesMetaClass</span><span class="params">(type)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(mcls, name, bases, attrs)</span>:</span></div><div class="line">        <span class="comment"># ... some code ...</span></div><div class="line">        d = dict(attrs)</div><div class="line">        declared_columns = []</div><div class="line">        <span class="keyword">for</span> name, value <span class="keyword">in</span> attrs.items():</div><div class="line">            <span class="keyword">if</span> isinstance(value, DataTablesColumn):</div><div class="line">                <span class="comment"># 为了能处理对related model的处理，属性名采用了类似Django的</span></div><div class="line">                <span class="comment"># attr__related_attr的属性路径表达方式.</span></div><div class="line">                <span class="comment"># 下面这个函数实现了根据属性路径获取到相应field的功能</span></div><div class="line">                field = _get_field(model, name)</div><div class="line">                <span class="keyword">if</span> field <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                value.name = name</div><div class="line">                value.field = field</div><div class="line">                declared_columns.append((name, value))</div><div class="line">                d.pop(name)</div><div class="line">        <span class="comment"># 采用OrderedDict保存，方便查询的同时，保证顺序</span></div><div class="line">        d[<span class="string">'_declared_columns'</span>] = OrderedDict(declared_columns)</div><div class="line"></div><div class="line">        <span class="comment"># 采用类似的方法，处理在Meta中指定的fields信息</span></div><div class="line">        <span class="comment"># ...</span></div><div class="line">        <span class="comment"># ...</span></div><div class="line"></div><div class="line">        <span class="comment"># ... some other code ...</span></div><div class="line"></div><div class="line"><span class="meta">    @classmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__prepare__</span><span class="params">(mcls, name, bases)</span>:</span></div><div class="line">        <span class="comment"># 重写这个方法，返回OrderedDict的实例，</span></div><div class="line">        <span class="comment"># 保证类声明中属性定义的顺序</span></div><div class="line">        <span class="keyword">return</span> OrderedDict()</div></pre></td></tr></table></figure>
<h2 id="DataTables-columns-顺序"><a href="#DataTables-columns-顺序" class="headerlink" title="DataTables columns 顺序"></a>DataTables columns 顺序</h2><p>在HTML table中column需要按照指定顺序生成header。<br>（返回的JSON数据没有顺序信息，这些数据会根据key映射到对应的HTML table column中）</p>
<ol>
<li>可以通过column_order list指定顺序，这种情况下，<code>column_order</code>需要包含所有声明的column以及Meta中指定的column；</li>
<li>如果没有指定column_order，则声明的column排在Meta中指定column的前面；</li>
</ol>
<h2 id="DataTablesColumn类"><a href="#DataTablesColumn类" class="headerlink" title="DataTablesColumn类"></a>DataTablesColumn类</h2><p><code>DataTablesColumn</code>类的实例用来保存DataTables中列的配置信息。</p>
<p>在通过声明的方式生成<code>DataTablesColumn</code>实例的情况下，这些信息可以通过<code>DataTablesColumn</code>类初始化的关键字参数指定；</p>
<p>而在通过<code>ModelDataTable</code>子类的<code>Meta</code>隐式自动生成<code>DataTableColumn</code>实例的时候，这些配置信息部分从绑定到的field实例信息获取。</p>
<p>可惜的是，<code>Django</code>内建的<code>Field</code>类型初始化时并不接受额外的关键字参数，除非使用自定义<code>Field</code>类型。所以不能通过在<code>Model-Field</code>定义的时候指定<code>DataTables</code>列相关的配置参数。</p>
<p><code>DataTablesColumn.title</code><br>用来指定HTML table的header部分显示的信息。<br>在没有设置的时候，默认获取对应field实例的verbose_name属性。</p>
<p><code>DataTablesColumn.width</code><br>指定column的宽度</p>
<p><code>DataTablesColumn.searchable</code><br>指定column是否可以被搜索。<br>默认为<code>True</code>。</p>
<p><code>DataTablesColumn.orderable</code><br>指定column是否可以排序。<br>默认为<code>True</code>。</p>
<p>下面是部分<code>DataTableColumn</code>类的定义（只包含对<code>title</code>配置的处理）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataTableColumn</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, title=None, field=None, **kwargs)</span>:</span></div><div class="line">        self.title = title</div><div class="line">        <span class="keyword">if</span> field <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">            self._initialize_from_field(field)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self._bound = <span class="keyword">False</span></div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">field</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># 不能直接读field属性</span></div><div class="line">        <span class="keyword">raise</span> AttributeError(<span class="string">'warning info ....'</span>)</div><div class="line"></div><div class="line"><span class="meta">    @field.setter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">field</span><span class="params">(self, value)</span>:</span></div><div class="line">        <span class="comment"># 绑定到对应field实例</span></div><div class="line">        self._initialize_from_field(value)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_initialize_from_field</span><span class="params">(self, field)</span>:</span></div><div class="line">        <span class="comment"># ... some code ...</span></div><div class="line">        <span class="keyword">if</span> self.title <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="comment"># 如果初始化时没有指定title，则使用绑定field的verbose name</span></div><div class="line">            self.title = field.verbose_name</div><div class="line">        self._field = field</div><div class="line">        self._bound = <span class="keyword">True</span></div><div class="line"></div><div class="line"><span class="meta">    @classmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_instance_from_field</span><span class="params">(cls, field)</span>:</span></div><div class="line">        <span class="comment"># 类方法，根据指定的field生成实例</span></div><div class="line">        <span class="keyword">return</span>  cls(field=field)</div><div class="line"></div><div class="line">    <span class="comment"># ... some other method definitions ...</span></div></pre></td></tr></table></figure></p>
<h2 id="Todos"><a href="#Todos" class="headerlink" title="Todos"></a>Todos</h2><ol>
<li>可以对dt_ajax参数设置dict；</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目标功能&quot;&gt;&lt;a href=&quot;#目标功能&quot; class=&quot;headerlink&quot; title=&quot;目标功能&quot;&gt;&lt;/a&gt;目标功能&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;通过ModelDataTables类定义，设置DataTables所需要的meta信息；&lt;/li&gt;
&lt;li&gt;通过
    
    </summary>
    
      <category term="Django" scheme="https://resettingmq.github.io/categories/Django/"/>
    
    
      <category term="Django" scheme="https://resettingmq.github.io/tags/Django/"/>
    
      <category term="DataTables" scheme="https://resettingmq.github.io/tags/DataTables/"/>
    
  </entry>
  
  <entry>
    <title>DataTables with Django</title>
    <link href="https://resettingmq.github.io/2017/07/05/datatables-with-django/"/>
    <id>https://resettingmq.github.io/2017/07/05/datatables-with-django/</id>
    <published>2017-07-05T06:12:33.000Z</published>
    <updated>2017-07-08T01:38:59.148Z</updated>
    
    <content type="html"><![CDATA[<p><code>DataTables</code>是前端很使用的一个库，能够已列表呈现数据。它具有很高的定制性，能够从多种数据源读取数据，并能提供分页，排序，搜索等功能。</p>
<p>这里就试图结合<code>Django</code>的<code>generic views</code>, <code>custom template tags</code>等特性，编写简单的接口，使得<code>DataTables</code>的配置更加方便直观，提高代码的可重用性。</p>
<p>##</p>
<p>DataTables用于控制列表的显示，所以主要用在某个<code>model</code>对应的<code>ListView</code>中。而每个model显示的项目，以及各项目的排序，搜索等配置也应该是不同的，所以在常规的使用中，每个model都对应这一份不同的DataTables配置对象。</p>
<p>在这里考虑以<code>model</code>为中心，将配置信息结合到model的属性中。在<code>ListView</code>渲染模板的时候，将对应<code>model</code>的<code>DataTable</code>配置信息读出，实现每个<code>DataTables</code>实例配置的差异化。</p>
<h2 id="generic-View的设计"><a href="#generic-View的设计" class="headerlink" title="generic View的设计"></a>generic View的设计</h2><p>为了简化URL设计，考虑在同一个view中同时实现对template的响应以及ajax的响应。<br>所以最终要实现的<code>DataTablesListView</code>除了继承<code>ListView</code>之外，还需要继承自一个能够生成<code>JsonResponse</code>对象的类。</p>
<p>同时，还需要在<code>DataTablesListView</code>中重写继承自<code>ListView</code>的<code>get()</code>函数。该函数最终用来处理<code>GET</code>请求（其实在<code>ListView</code>中，<code>POST</code>等请求最终也是通过这个函数来处理的）。在<code>get()</code>函数中，通过判断请求是否来自于ajax，从而决定调用基类的哪个方法来生成最终的响应。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataTablesListView</span><span class="params">(DataTablesMixin, ListView)</span>:</span></div><div class="line">    ... some code ...</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, *args, **kwargs)</span>:</span></div><div class="line">        <span class="keyword">if</span> reuqest.is_ajax():</div><div class="line">            <span class="keyword">return</span> self.render_to_json_response(some_context)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> super().get(request, *args, **kwargs)</div></pre></td></tr></table></figure>
<p>前面已经提到，<code>DataTablesListView</code>除了继承<code>ListView</code>之外，还继承一个名为<code>DataTableMixin</code>的类，这个类封装了一些同DataTable渲染以及数据生成相关的属性和方法。</p>
<p><code>DataTableMixin</code>这个类继承自<code>JsonResponseMixin</code>以及<code>JsonContextMixin</code>。</p>
<p><code>JsonResponseMixin</code>类实现了<code>render_to_json_repsonse()</code>方法，用于生成<code>JsonResponse</code>对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonResponseMixin</span>:</span></div><div class="line">    json_response_class = JsonResponse</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">render_to_json_response</span><span class="params">(self, context, **response_kwargs)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.json_response_class(context, **response_kwargs)</div></pre></td></tr></table></figure>
<p><code>JsonContextMixin</code>类中定义了<code>get_json_context_data()</code>方法，这个方法返回用于<code>JsonResponse</code>对象所需要的数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonContextMixin</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_json_context_data</span><span class="params">(self, **kwargs)</span>:</span></div><div class="line">        <span class="keyword">return</span> kwargs</div></pre></td></tr></table></figure>
<p><img src="/2017/07/05/datatables-with-django/inheritance_hierarchy.jpg" alt="Inheritance Hierarchy"></p>
<h2 id="JSON数据的生成"><a href="#JSON数据的生成" class="headerlink" title="JSON数据的生成"></a><code>JSON</code>数据的生成</h2><p>因为继承自<code>ListView</code>，所以我们可以直接使用<code>get_queryset()</code>方法来获取数据源。</p>
<p>但是在这里并没有将<code>get_queryset()</code>返回的<code>queryset</code>对象序列化成<code>JSON</code>数据，而是通过<code>queryset</code>对象的<code>values()</code>方法，先生成一系列<code>dict</code>的<code>queryset</code>；再将这个<code>queryset</code>对象转换成<code>list</code>。</p>
<p><code>JSON</code>数据中的键，由定义在<code>DataTablesMixin</code>中的<code>dt_data_src</code>属性定义。</p>
<p>同时，<code>queryset</code>的<code>values()</code>方法还支持指定获取的<code>field</code>，这样不仅能够避免不希望的数据返回到前端，还能够减少Web应用与数据库以及客户端之间的数据传输。</p>
<p>为此，<code>DataTablesMixin</code>中定义了<code>dt_column_fields</code>属性。这个属性是一个字符串列表，可以通过该属性一个字符串列表，用来限定<code>JSON</code>返回数据。</p>
<p>同时，<code>DataTablesMixin</code>还定义了<code>get_dt_column_fields()</code>方法，在没有指定<code>dt_column_fields</code>属性的时候，该函数会试图从<code>ListView</code>的<code>query_set</code>中获取<code>model</code>，再从<code>model.DataTablesMeta.column_fields</code>中获取限定<code>JSON</code>返回的字符串列表。</p>
<p>如果这两种情况下都没有获取成功，则最终返回的<code>JSON</code>数据会包含所有的<code>fields</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataTablesMixin</span><span class="params">(JsonResponseMixin, JsonContextMixin)</span>:</span></div><div class="line">    dt_data_src = <span class="string">'data'</span></div><div class="line">    dt_column_fields = <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_dt_column_fields</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.dt_column_fields <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> self.dt_column_fields</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            model = self.get_queryset().model</div><div class="line">            dt_column_fields = model.DataTablesMeta.column_fields.keys()</div><div class="line">        <span class="keyword">except</span> AttributeError:</div><div class="line">            <span class="keyword">return</span> []</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> dt_column_fields</div></pre></td></tr></table></figure>
<h2 id="对DataTables的serverSide模式下请求的处理"><a href="#对DataTables的serverSide模式下请求的处理" class="headerlink" title="对DataTables的serverSide模式下请求的处理"></a>对<code>DataTables</code>的<code>serverSide</code>模式下请求的处理</h2><p>在<code>serverSide</code>模式下，客户端发出的ajax请求包含一系列<code>query args</code>，对返回的结果集进行限定（例如分页，排序，搜索等等）。请求处理函数中，需要对这些<code>query args</code>进行处理。</p>
<p>所以，需要在get()函数中，将<code>request.GET</code>作为参数传入到<code>get_json_context_data()</code>中，在<code>get_json_context_data()</code>函数中集中对数据进行查询等处理。</p>
<p>同时，DataTables还要求后端返回一些额外数据，用于数据验证以及前端的显示（例如分页信息）。这些信息包括：</p>
<ul>
<li><code>draw</code></li>
<li><code>recordsTotal</code></li>
<li><code>recordsFiltered</code></li>
<li><code>error</code>（仅在由错误的情况下返回错误相关信息）<br>因此，需要在后端代码中生成这些信息并且正确返回。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;DataTables&lt;/code&gt;是前端很使用的一个库，能够已列表呈现数据。它具有很高的定制性，能够从多种数据源读取数据，并能提供分页，排序，搜索等功能。&lt;/p&gt;
&lt;p&gt;这里就试图结合&lt;code&gt;Django&lt;/code&gt;的&lt;code&gt;generic views
    
    </summary>
    
      <category term="Django" scheme="https://resettingmq.github.io/categories/Django/"/>
    
    
      <category term="Python" scheme="https://resettingmq.github.io/tags/Python/"/>
    
      <category term="Django" scheme="https://resettingmq.github.io/tags/Django/"/>
    
      <category term="DataTables" scheme="https://resettingmq.github.io/tags/DataTables/"/>
    
  </entry>
  
  <entry>
    <title>flask_web_开发_测试驱动开发</title>
    <link href="https://resettingmq.github.io/2017/05/21/flask-web-%E5%BC%80%E5%8F%91-%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    <id>https://resettingmq.github.io/2017/05/21/flask-web-开发-测试驱动开发/</id>
    <published>2017-05-21T14:27:25.000Z</published>
    <updated>2017-05-21T15:12:17.067Z</updated>
    
    <content type="html"><![CDATA[<p>开始看Miguel Grinberg所著的Flask Web开发，试着利用测试驱动的方式把书中的例子自己实现一遍，在这里记录一下在这个过程中自己的一些心得体会。</p>
<h2 id="功能模块-vs-逻辑模块"><a href="#功能模块-vs-逻辑模块" class="headerlink" title="功能模块 vs. 逻辑模块"></a>功能模块 vs. 逻辑模块</h2><p>首先遇到的选择是<code>TestCase</code>的划分。例如在用户认证的模块中，需要建立请求url<code>url rule</code>到视图函数<code>view_func</code>映射关系的测试。</p>
<p>如果把对于所有逻辑模块（例如用户认证模块等）的映射测试放到一个单独的<code>TestCase</code>中，这样就可以方便的在这个<code>TestCase</code>中加入对映射关系测试需要用到的辅助函数，便于代码重用和调试。</p>
<p>如果把所有的某个逻辑模块的url映射测试放到各模块对应的<code>TestCase</code>中，方便于逻辑模块的增删，不需要修改多个测试文件。在这种方式下，可以将url关系测试的辅助函数放入<code>TestCaseMixin</code>中，这样也能达到代码重用的目的，而不需要在各逻辑模块的测试用分别定义这些辅助函数。</p>
<h2 id="TestCase-Mixin"><a href="#TestCase-Mixin" class="headerlink" title="TestCase Mixin"></a>TestCase Mixin</h2><p>在各逻辑模块的<code>TestCase</code>中，包含着需要相同的测试逻辑。例如，对表单响应中应该包含<code>csrf_token</code>的测试。对于这些测试，也可以提取到<code>Mixin</code>中。</p>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ol>
<li>在测试用例中如果需要用到<code>url_for()</code>，则需要保证由活动的<code>app_context</code>，同时还需要设置<code>app.config</code>的<code>SERVER_NAME</code>的配置值。</li>
</ol>
<p>这是因为<code>url_for()</code>需要用到<code>MapAdapter</code>对象来匹配<code>url rule</code>与<code>endpoint</code>之间的映射关系。这个对象是在<code>ApplicationContext</code>或者<code>RequestContext</code>初始化的时候被建立的，所以至少需要保证有活动的<code>app_context</code>。</p>
<p>同时，<code>MapAdapter</code>对象建立至少需要<code>SERVER_NAME</code>参数（或者<code>environ</code>对象），所以在测试初始化的时候，需要配置<code>app.config</code>，使之正确设置<code>SERVER_NAME</code>的值。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开始看Miguel Grinberg所著的Flask Web开发，试着利用测试驱动的方式把书中的例子自己实现一遍，在这里记录一下在这个过程中自己的一些心得体会。&lt;/p&gt;
&lt;h2 id=&quot;功能模块-vs-逻辑模块&quot;&gt;&lt;a href=&quot;#功能模块-vs-逻辑模块&quot; class=
    
    </summary>
    
      <category term="Flask" scheme="https://resettingmq.github.io/categories/Flask/"/>
    
    
      <category term="Flask" scheme="https://resettingmq.github.io/tags/Flask/"/>
    
      <category term="Python" scheme="https://resettingmq.github.io/tags/Python/"/>
    
      <category term="TDD" scheme="https://resettingmq.github.io/tags/TDD/"/>
    
  </entry>
  
  <entry>
    <title>Werkzeug_Thread_Local学习</title>
    <link href="https://resettingmq.github.io/2017/04/30/Werkzeug-Thread-Local%E5%AD%A6%E4%B9%A0/"/>
    <id>https://resettingmq.github.io/2017/04/30/Werkzeug-Thread-Local学习/</id>
    <published>2017-04-30T10:55:46.000Z</published>
    <updated>2017-04-30T18:18:53.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>在学习<code>Flask</code>的过程中，经常遇到<code>context</code>的这个概念。通过<code>app context</code>和<code>request context</code>，可以使不同请求之间的数据得到隔离。开发的过程中，只知道怎么使用这两个<code>context</code>，却不理解它们背后的运行机制以及使用的过程中的限制和注意点。借助这几天对<code>Flask</code>以及<code>Werkzeug</code>源码的初步阅读，希望能够更深入的理解它们。</p>
<p>先看一下<a href="http://werkzeug.pocoo.org/docs/0.11/local/#werkzeug.local.LocalStack" target="_blank" rel="external"><code>Werkzeug official document</code></a>中的一些描述：</p>
<blockquote>
<p><cite> The Python standard library has a concept called “thread locals” (or thread-local data). A thread local is a global object in which you can put stuff in and get back later in a thread-safe and thread-specific way. That means that whenever you set or get a value on a thread local object, the thread local object checks in which thread you are and retrieves the value corresponding to your thread (if one exists). So, you won’t accidentally get another thread’s data. </cite></p>
</blockquote>
<p>首先，通过<code>Python</code>内建的<code>Thread Local</code>，可以实现不同进程数据之间的隔离。这个可以满足Web Server对每个请求生成一个<code>Thread</code>进行处理的场景。而在一些使用其它并发机制的Web Server上，仅仅使用<code>Python Thread Local</code>显然并不能满足需求。</p>
<blockquote>
<p><cite> This approach, however, has a few disadvantages. For example, besides threads, there are other types of concurrency in Python. A very popular one is greenlets. Also, whether every request gets its own thread is not guaranteed in WSGI. It could be that a request is reusing a thread from a previous request, and hence data is left over in the thread local object. </cite></p>
</blockquote>
<p>于是，<code>Werkzeug</code>就使用了自己的<code>Local</code>机制来替换<code>Python Thread Local</code>，这就是<a href="https://github.com/pallets/werkzeug/blob/master/werkzeug/local.py" target="_blank" rel="external"><code>werkzeug.local.Local</code></a>类。</p>
<h2 id="对werkzeug-local-Local类的分析"><a href="#对werkzeug-local-Local类的分析" class="headerlink" title="对werkzeug.local.Local类的分析"></a>对<code>werkzeug.local.Local</code>类的分析</h2><blockquote>
<p><em>以下的代码省略了部分不相关代码以及注释，以方便阅读。</em></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Local</span><span class="params">(object)</span>:</span></div><div class="line">    __slots__ = (<span class="string">'__storage__'</span>, <span class="string">'__ident_func__'</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        object.__setattr__(self, <span class="string">'__storage__'</span>, &#123;&#125;)</div><div class="line">        object.__setattr__(self, <span class="string">'__ident_func__'</span>, get_ident)</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            <span class="keyword">return</span> self.__storage__[self.__ident_func__][name]</div><div class="line">        <span class="keyword">except</span> KeyError:</div><div class="line">            <span class="keyword">raise</span> AttributeError(name)</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, name, value)</span>:</span></div><div class="line">        ident = self.__ident_func__()</div><div class="line">        storage = self.__storage__</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            storage[ident][name] = value</div><div class="line">        <span class="keyword">except</span> KeyError:</div><div class="line">            storage[ident] = &#123;name: value&#125;</div></pre></td></tr></table></figure>
<p><code>Local</code>对象中只含有两个属性: <code>__storage__</code>和<code>__ident_func__</code>，其中：</p>
<ul>
<li><code>__ident_func__</code>是用来获取当前<code>context</code>的全局唯一标识符，在本文下面会提到；</li>
<li><code>__storage__</code>用来存储<code>context</code>数据，是一个{<code>context</code>标识符: <code>context</code>数据}形式的字典；其中<code>context</code>数据是一个{key: value}形式的字典。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>:</div><div class="line">    <span class="keyword">from</span> greenlet <span class="keyword">import</span> getcurrent <span class="keyword">as</span> get_ident</div><div class="line"><span class="keyword">except</span> ImportError:</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="keyword">from</span> thread <span class="keyword">import</span> get_ident</div><div class="line">    <span class="keyword">except</span> ImportError:</div><div class="line">        <span class="keyword">from</span> _thread <span class="keyword">import</span> get_ident</div></pre></td></tr></table></figure>
<p>这段代码先试图从<code>greenlet</code>库中导入<a href="http://greenlet.readthedocs.io/en/latest/index.html?highlight=getcurrent" target="_blank" rel="external"><code>getcurrent</code></a>函数。如果导入失败（即项目中没有使用基于<code>greenlet</code>库的服务），则从<code>Python thread</code>或者<code>Python _thread</code>模块中导入<code>get_ident</code>函数。</p>
<p>这些函数可以得到当前<code>greenlet</code>或是<code>thread</code>的全局唯一标识符。</p>
<p>由此也可以看出，<code>Werkzeug</code>的<code>Thread Local</code>仅支持基于<code>thread</code>或<code>greenlet</code>分发请求的Web Server。这有可能是一个坑，如果<code>Web Server</code>使用在这之外的并发机制来分发请求，那么不同请求的数据就会耦合在一起。这需要在了解个<code>WSGI Server</code>使用的并发技术之后才能更深入的了解。</p>
<blockquote>
<p><em>todo:uWSGI/Gevent/Tornado/greenlet</em></p>
</blockquote>
<h2 id="对werkzeug-local-LocalStack的分析"><a href="#对werkzeug-local-LocalStack的分析" class="headerlink" title="对werkzeug.local.LocalStack的分析"></a>对<code>werkzeug.local.LocalStack</code>的分析</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocalStack</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self._local = Local()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, obj)</span>:</span></div><div class="line">        rv = getattr(self._local, <span class="string">'stack'</span>, <span class="keyword">None</span>)</div><div class="line">        <span class="keyword">if</span> rv <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            self._local.stack = rv = []</div><div class="line">        rv.append(obj)</div><div class="line">        <span class="keyword">return</span> rv</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></div><div class="line">        stack = getattr(self._local, <span class="string">'stack'</span>, <span class="keyword">None</span>)</div><div class="line">        <span class="keyword">if</span> stack <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">        <span class="keyword">if</span> len(stack) == <span class="number">1</span>:</div><div class="line">            release_local(self._local)</div><div class="line">            <span class="keyword">return</span> stack[<span class="number">-1</span>]</div><div class="line">        <span class="keyword">return</span> stack.pop()</div></pre></td></tr></table></figure>
<p><code>LocalStack</code>内部维护一个<code>Local</code>实例，该实例对每个<code>context</code>有一个<code>stack</code>数组，因此这个栈结构也是对不同<code>context</code>隔离的。</p>
<p><code>LocalStack.pop()</code>和<code>LocalStack.push()</code>可以在当前<code>context</code>下添加对象。</p>
<p>这个栈结构是通过<code>Python List</code>来实现的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_lookup</span><span class="params">()</span>:</span></div><div class="line">            rv = self.top</div><div class="line">            <span class="keyword">if</span> rv <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">                <span class="keyword">raise</span> RuntimeError(<span class="string">'object unbound'</span>)</div><div class="line">            <span class="keyword">return</span> rv</div><div class="line">        <span class="keyword">return</span> LocalProxy(_lookup)</div></pre></td></tr></table></figure>
<p>同时，<code>LocalStack</code>还定义了<code>__call__</code>魔法方法。调用<code>LocalStack</code>的对象实例，会返回一个<code>LocalProxy</code>对象，该对象代表的是对应<code>LocalStack</code>的栈顶元素;如果栈为空（这种情况下<code>LocalStack._local.stack</code>属性不存在）就会抛出<code>RuntimeError</code>。</p>
<h2 id="werkzeug-local-LocalManager"><a href="#werkzeug-local-LocalManager" class="headerlink" title="werkzeug.local.LocalManager"></a><code>werkzeug.local.LocalManager</code></h2><p><code>LocalManager.locals</code>属性是<code>Local</code>对象列表。<br>在<code>LocalManager</code>对象初始化时，可以指定<code>ident_func</code>关键字参数，该参数会将初始化关键字参数<code>locals</code>列表中各<code>Local</code>对象的<code>__ident_func__</code>属性的值更改为<code>ident_func</code>指定的函数。</p>
<p><code>LocalManager</code>的作用在于，可以通过<code>LocalManager.make_middleware</code>或<code>LocalManager.middleware</code>修饰一个<code>callable</code>对象，在该<code>callable</code>对象上调用<code>close</code>方法的时候，会自动调用<code>LocalManager.locals</code>中管理的<code>Local</code>对象的<code>__release_local__</code>函数，从而清除<code>Local</code>对象在当前<code>context</code>中的数据。</p>
<h2 id="werkzeug-local-LocalProxy"><a href="#werkzeug-local-LocalProxy" class="headerlink" title="werkzeug.local.LocalProxy"></a><code>werkzeug.local.LocalProxy</code></h2><p><code>LocalProxy</code>对象是一个代理对象。</p>
<p>如果指定初始化参数指定一个<code>Local</code>对象和一个属性名，则<code>LocalProxy</code>对象代理的对象为<code>Local.attribute_name</code>；如果初始化参数为一个函数，则<code>LocalProxy</code>对象代理的对象为该函数的返回值。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Preface&quot;&gt;&lt;a href=&quot;#Preface&quot; class=&quot;headerlink&quot; title=&quot;Preface&quot;&gt;&lt;/a&gt;Preface&lt;/h2&gt;&lt;p&gt;在学习&lt;code&gt;Flask&lt;/code&gt;的过程中，经常遇到&lt;code&gt;context&lt;/code&gt;
    
    </summary>
    
      <category term="Flask" scheme="https://resettingmq.github.io/categories/Flask/"/>
    
    
      <category term="Flask" scheme="https://resettingmq.github.io/tags/Flask/"/>
    
      <category term="Werkzeug" scheme="https://resettingmq.github.io/tags/Werkzeug/"/>
    
      <category term="Python" scheme="https://resettingmq.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>flask分析_WSGI程序调用</title>
    <link href="https://resettingmq.github.io/2017/04/29/flask%E5%88%86%E6%9E%90-WSGI%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8/"/>
    <id>https://resettingmq.github.io/2017/04/29/flask分析-WSGI程序调用/</id>
    <published>2017-04-29T14:36:23.000Z</published>
    <updated>2017-05-04T04:38:06.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>根据WSGI协议，<code>WSGI application</code>向<code>WSGI Server</code>提供一个可调用对象。当<code>WSGI Server</code>分发请求时，调用该对象，并将当前环境参数<code>environ</code>以及一个<code>callback</code>函数<code>start_response</code>传入该可调用对象。</p>
<h2 id="Flask-Application调用入口"><a href="#Flask-Application调用入口" class="headerlink" title="Flask Application调用入口"></a><code>Flask Application</code>调用入口</h2><p>先从最简单的<code>WSGI application</code>入手：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> flask</div><div class="line"></div><div class="line">app = flask.Flask(__name__)</div><div class="line"></div><div class="line"><span class="meta">@app.route('/')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'Hello, world!'</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    app.run(debug=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<p>在这段代码中，<code>app.run()</code>启动了<code>werkzeug</code>内建的一个简单的<code>WSGI Server</code>。启动这个<code>WSGI Server</code>的时候，将<code>Flask</code>的实例<code>app</code>作为可调用对象传入了<code>WSGI Server</code>。所以，要分析<code>WSGI</code>程序的调用过程，重点在于<code>WSGI Server</code>将请求分发到这个<code>WSGI application</code>的时候，<code>Flask</code>的实例<code>app</code>是如何被调用的。</p>
<p>先看<code>Flask.__call__()</code>的代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># flask/app.py</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flask</span><span class="params">(_PackageBoundObject)</span>:</span></div><div class="line">    <span class="comment"># ...</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, environ, start_response)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.self.wsgi_app(environ, start_response)</div><div class="line"></div><div class="line">    <span class="comment"># ...</span></div></pre></td></tr></table></figure>
<p>所以，在<code>app</code>对象被调用的时候，实际上调用了<code>app.wsgi_app(environ, start_response)</code>，也即，在<code>WSGI Server</code>分发处理请求时调用的是<code>app.wsgi_app(environ, start_response)</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># flask/app.py</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flask</span><span class="params">(_PackageBoundObject)</span>:</span></div><div class="line">    <span class="comment"># ...</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wsgi_app</span><span class="params">(self, environ, start_response)</span>:</span></div></pre></td></tr></table></figure>
<h2 id="Flask-wsgi-app-的基本执行流程"><a href="#Flask-wsgi-app-的基本执行流程" class="headerlink" title="Flask.wsgi_app()的基本执行流程"></a><code>Flask.wsgi_app()</code>的基本执行流程</h2><p>在<code>Flask</code>实例调用<code>wsgi_app()</code>的过程，主要分为一下几个步骤（暂时先忽略错误处理部分）：</p>
<ol>
<li>对传入的<code>environ</code>环境变量生成<code>RequestContext</code>，并<code>push</code>到<code>_request_ctx_stack</code>中；</li>
<li>分发请求，获取<code>Response</code>响应对象；</li>
<li>返回响应，并调用<code>WSGI Server</code>传入的<code>callback</code>:<code>start_response</code>；</li>
<li>从<code>_request_ctx_stack</code>中弹出当前<code>request_context</code>。</li>
</ol>
<p>下面从这几个部分进行分析：</p>
<h3 id="1-请求上下文RequestContext对象的生成"><a href="#1-请求上下文RequestContext对象的生成" class="headerlink" title="1. 请求上下文RequestContext对象的生成"></a>1. 请求上下文<code>RequestContext</code>对象的生成</h3><p><code>Flask.request_context(environ)</code>函数生成并返回一个请求上下文对象，这个对象是<code>flask.ctx.RequestContext</code>的实例。</p>
<blockquote>
<p><em>在命令行进行测试的过程中，也可以通过`Flask.test_request_context(</em>args, <em>*kwargs)`函数来得到一个请求上下文。</em></p>
</blockquote>
<p>请求上下文对象包括了</p>
<h3 id="2-请求分发"><a href="#2-请求分发" class="headerlink" title="2. 请求分发"></a>2. 请求分发</h3><p>请求分发包括以下顺序进行：</p>
<ol>
<li>执行用<code>before_first_request()</code>注册的函数（如果是该程序的第一次请求）；</li>
<li>执行用<code>url_value_processor()</code>注册的函数；</li>
<li>执行用<code>before_request()</code>注册的函数；如果其中有函数返回<code>non-None</code>的值，则直接跳到第5步；</li>
<li>分发请求，执行该请求<code>URL</code>对应的<code>view function</code></li>
<li>根据步骤3或步骤4的结果生成<code>response</code>对象</li>
<li>执行用<code>after_request()</code>注册的函数，处理并返回上一步生成的<code>response</code>对象，在这个过程中，可以修改<code>response</code>对象或者替换为全新的<code>response</code>对象；</li>
<li>处理<code>session</code>（如果使用<code>session</code>）</li>
</ol>
<p>其中，步骤1-3中的函数，先执行使用<code>Flask</code>实例对象装饰器注册的函数，再执行使用<code>Blueprint</code>实例对象装饰器注册的函数；用同一个装饰器注册的函数，按照它们在代码中先后的顺序执行。<br>而步骤6中的函数执行顺序则相反：先执行使用<code>Blueprint</code>实例对象装饰器注册的函数，再执行使用<code>Flask</code>实例对象装饰器注册的函数；用同一个装饰器注册的函数，按照它们再代码中先后的顺序相反的顺序执行。</p>
<h3 id="3-返回响应"><a href="#3-返回响应" class="headerlink" title="3. 返回响应"></a>3. 返回响应</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Preface&quot;&gt;&lt;a href=&quot;#Preface&quot; class=&quot;headerlink&quot; title=&quot;Preface&quot;&gt;&lt;/a&gt;Preface&lt;/h2&gt;&lt;p&gt;根据WSGI协议，&lt;code&gt;WSGI application&lt;/code&gt;向&lt;code&gt;WSGI 
    
    </summary>
    
      <category term="flask" scheme="https://resettingmq.github.io/categories/flask/"/>
    
    
      <category term="python" scheme="https://resettingmq.github.io/tags/python/"/>
    
      <category term="flask" scheme="https://resettingmq.github.io/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>flask分析_routing</title>
    <link href="https://resettingmq.github.io/2017/04/27/flask%E5%88%86%E6%9E%90-routing/"/>
    <id>https://resettingmq.github.io/2017/04/27/flask分析-routing/</id>
    <published>2017-04-27T04:34:09.000Z</published>
    <updated>2017-04-27T04:35:31.441Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="flask" scheme="https://resettingmq.github.io/categories/flask/"/>
    
    
      <category term="python" scheme="https://resettingmq.github.io/tags/python/"/>
    
      <category term="flask" scheme="https://resettingmq.github.io/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>flask分析_import_name</title>
    <link href="https://resettingmq.github.io/2017/04/27/flask%E5%88%86%E6%9E%90-import-name/"/>
    <id>https://resettingmq.github.io/2017/04/27/flask分析-import-name/</id>
    <published>2017-04-27T01:59:23.000Z</published>
    <updated>2017-04-27T04:35:07.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>According to <a href="http://flask.pocoo.org/docs/0.12/quickstart/#quickstart" target="_blank" rel="external">Flask Quickstart</a>:</p>
<blockquote>
<p><cite> This is needed so that Flask knows where to look for templates, static files, and so on. </cite></p>
</blockquote>
<p>And <a href="http://flask.pocoo.org/docs/0.12/api/#flask.Flask" target="_blank" rel="external">Flask API definition</a>:</p>
<blockquote>
<p><cite> The idea of the first parameter is to give Flask an idea of what belongs to your application. This name is used to find resources on the files system, can be used by extensions to improve debugging information and a lot more. </cite></p>
</blockquote>
<p>Flask实例根据<code>import_name</code>确定<code>templates</code>，<code>static files</code>等组件在文件系统中的查找路径。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># flask/app.py</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flask</span><span class="params">(_PackageBoundObject)</span>:</span></div><div class="line">    <span class="comment"># ... </span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, static_folder=<span class="string">'static'</span>, template_folder=<span class="string">'templates'</span>, root_path=None, ...)</span>:</span></div><div class="line">        _PackageBoundObject.__init__(self, import_name,</div><div class="line">                                    template_folder=template_folder,</div><div class="line">                                    static_folder=static_folder,</div><div class="line">                                    root_path=root_path)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># flask/helpers.py</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">_PackageBoundObject</span><span class="params">()</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, import_name, template_folder=None, static_folder=None, root_path=None)</span>:</span></div><div class="line">        self.import_name = import_name</div><div class="line">        self.template_folder = template_folder</div><div class="line"></div><div class="line">        <span class="keyword">if</span> root_path <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            root_path = get_root_path(self.import_name)</div><div class="line">        self.root_path = root_path</div><div class="line">        <span class="comment"># ... more codes ...</span></div><div class="line">    <span class="comment"># ... more codes ...</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_root_path</span><span class="params">(import_name)</span>:</span></div><div class="line">    mod = sys.modules.get(import_name)</div><div class="line">    <span class="keyword">if</span> mod <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> hasattr(mod, <span class="string">'__file__'</span>):</div><div class="line">        <span class="keyword">return</span> os.path.basename(os.path.abspath(mod.__file__))</div><div class="line">    </div><div class="line">    loader = pkgutil.get_loader(import_name)</div><div class="line">    <span class="keyword">if</span> loader <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> import_name == <span class="string">'__main__'</span>:</div><div class="line">        <span class="keyword">return</span> os.getcwd()</div></pre></td></tr></table></figure>
<p><code>Flask</code>类继承自<code>_PackageBoundObject</code>.<br>可以看到，<code>Flask</code>对象中存在一个<code>root_path</code>属性：</p>
<ul>
<li>如果在初始化<code>Flask</code>对象时没有设置该属性，该属性的值由<code>import_name</code>的值计算得到；</li>
<li>如果在初始化<code>Flask</code>对象时设置了<code>root_path</code>的值，则使用该指定值。</li>
</ul>
<p>参考<a href="http://flask.pocoo.org/docs/0.12/api/#application-object" target="_blank" rel="external">Flask API definition</a>:</p>
<blockquote>
<p><cite> <strong>root_path</strong> - Flask by default will automatically calculate the path to the root of the application. In certain situations this cannot be achieved (for instance if the package is a Python 3 namespace package) and needs to be manually defined. </cite></p>
</blockquote>
<p>那么，<code>Flask.root_path</code>属性有什么作用呢？</p>
<p>例如，在<code>Flask.jinja_loader()</code>中，根据<code>Flask.root_path</code>和<code>Flask.template_folder</code>返回<code>loader</code>。</p>
<p>又如，在<code>Flask.open_resource()</code>方法中，<code>resource</code>也是相对<code>Flask.root_path</code>的路径得到的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Preface&quot;&gt;&lt;a href=&quot;#Preface&quot; class=&quot;headerlink&quot; title=&quot;Preface&quot;&gt;&lt;/a&gt;Preface&lt;/h2&gt;&lt;p&gt;According to &lt;a href=&quot;http://flask.pocoo.org/docs/
    
    </summary>
    
      <category term="flask" scheme="https://resettingmq.github.io/categories/flask/"/>
    
    
      <category term="python" scheme="https://resettingmq.github.io/tags/python/"/>
    
      <category term="flask" scheme="https://resettingmq.github.io/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>lxml.html学习笔记</title>
    <link href="https://resettingmq.github.io/2017/04/23/lxml-html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://resettingmq.github.io/2017/04/23/lxml-html学习笔记/</id>
    <published>2017-04-23T13:25:16.000Z</published>
    <updated>2017-04-24T16:04:24.928Z</updated>
    
    <content type="html"><![CDATA[<p>虽然Scrapy中采用了lxml作为xml/html的解析器，能够方便的解析xml/html文档树，但是在学习爬虫的时候，仍有时希望跳出Scrapy框架，写一些简单的爬虫或者对页面结构的测试。这个时候，就需要BetifulSoup/lxml/正则表达式这些工具了。</p>
<p>这里简单的记录一下lxml.html库的api。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>lxml.html库建立在lxml的HTML parser的基础之上，针对HTML元素提供了一组特殊的Element API，以及一些实用的Utilities。</p>
<h2 id="生成html文档对象"><a href="#生成html文档对象" class="headerlink" title="生成html文档对象"></a>生成html文档对象</h2><p>HTML文档以及其中的元素在经过解析后，表示为一个<a href="http://lxml.de/api/index.html" target="_blank" rel="external"><code>lxml.html.HtmlElement</code></a>对象。</p>
<p>有以下的方法能够通过字符串或者文件对象，用来创建HTML文档或者元素对象。</p>
<ul>
<li><p><code>parse(filename_url_or_file)</code></p>
<p>  从文件对象中解析HTML文档或元素。</p>
</li>
<li><p><code>document_fromstring(string)</code></p>
<p>  从字符串参数中解析HTML文档。</p>
<p>  返回的结果一定是一个合法的HTML文档，也就是说最外层元素标签为<code>&lt;html&gt;&lt;/html&gt;</code>，并且具有一对<code>&lt;body&gt;&lt;/body&gt;</code>元素标签和一对可选的<code>&lt;head&gt;&lt;/head&gt;</code>标签。</p>
</li>
<li><p><code>fragment_fromstring(string, create_parent=False)</code></p>
<p>  从字符串参数中解析出<strong>一个</strong>HTML元素。</p>
<p>  在指定了<code>create_parent</code>参数的情况下，解析结果的外层会由该参数指定的元素标签包裹。</p>
</li>
<li><p><code>fragmens_fromstring(string)</code></p>
<p>  返回一个元素列表。</p>
</li>
<li><p><code>fromstring(string)</code></p>
<p>  根据字符串参数内容判断，采用<code>document_fromstring</code>或者<code>fragment_fromstring</code>来解析字符串参数，返回一个HTML文档或者一个HTML元素。</p>
</li>
</ul>
<h2 id="lxml-html-HtmlElement-的属于与方法"><a href="#lxml-html-HtmlElement-的属于与方法" class="headerlink" title="lxml.html.HtmlElement 的属于与方法"></a><code>lxml.html.HtmlElement</code> 的属于与方法</h2><p><code>lxml.html.HtmlElement</code>继承自<a href="http://lxml.de/api/lxml.etree.ElementBase-class.html" target="_blank" rel="external"><code>lxml.etree.ElementBase</code></a>和<a href="http://lxml.de/api/lxml.html.HtmlMixin-class.html" target="_blank" rel="external"><code>lxml.html.HtmlMixin</code></a>，所以<code>HtmlElement</code>对象中包含了一些修改HTML文档以及元素的方法。<br>这里仅介绍一些常用的爬虫相关的属性以及元素查询方法。</p>
<ul>
<li><code>find_class(class_name)</code></li>
<li><code>find_rel_links(rel)</code></li>
<li><code>get_element_by_id(id, default=None)</code></li>
<li><code>text_content()</code></li>
<li><code>cssselect(expr)</code></li>
<li><code>xpath(expr)</code></li>
</ul>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://lxml.de/lxmlhtml.html" target="_blank" rel="external">lxml.html Documentation</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然Scrapy中采用了lxml作为xml/html的解析器，能够方便的解析xml/html文档树，但是在学习爬虫的时候，仍有时希望跳出Scrapy框架，写一些简单的爬虫或者对页面结构的测试。这个时候，就需要BetifulSoup/lxml/正则表达式这些工具了。&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>coroutine学习笔记</title>
    <link href="https://resettingmq.github.io/2017/04/23/coroutine%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://resettingmq.github.io/2017/04/23/coroutine学习笔记/</id>
    <published>2017-04-23T09:33:51.000Z</published>
    <updated>2017-04-27T02:00:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前面的话"><a href="#前面的话" class="headerlink" title="前面的话"></a>前面的话</h2><p>这个星期在研究Scrapy media Pipeline源码 (<a href="https://github.com/scrapy/scrapy/blob/master/scrapy/pipelines/media.py" target="_blank" rel="external">scrapy.pipelines.images</a>)的时候，遇到文档中一直被跳过阅读的Deferred对象，于是就打算尝试去理解一下Twisted。但由于基础不过硬，在基本的事件驱动模型上都没有理解透彻，所以打算从异步编程的基础开始学习。</p>
<p>之前在廖雪峰大师的博客中看了一遍异步IO相关的<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143208573480558080fa77514407cb23834c78c6c7309000" target="_blank" rel="external">教程</a>,了解到了coroutine（协程）这样一个概念，这篇文章中打算记录一下学习过程中的心得。</p>
<p>是不是很晕？我就这样很容易的从Scrapy源码被带到了coroutine，一向如此，看到不了解的东西就像去深究其中究竟，导致战线拉太长，效率不高，简单的东西没精通掌握，复杂的东西又没透彻学会。以后要学会适时忽略细节，在掌握整体之后再来深究部分。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>协程的定义类似于普通函数的定义：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">coroutine_name</span><span class="params">()</span>:</span></div><div class="line">    <span class="comment"># defines your coroutine here.</span></div></pre></td></tr></table></figure></p>
<p>但协程的执行过程与普通函数不同。</p>
<p>普通函数的执行总是有一个入口，一次返回；但是协程的执行可以在其内部中断，由自己控制转到其它协程的代码中执行，之后在一定的时间返回到这个协程中继续执行。</p>
<p>多个协程是在一个进程中运行的。</p>
<h2 id="同其他常用异步技术的比较"><a href="#同其他常用异步技术的比较" class="headerlink" title="同其他常用异步技术的比较"></a>同其他常用异步技术的比较</h2><p>协程的这一个特点与多进程/多线程相似，但是不同的是多进程/多线程程序在运行过程中，进程/线程之间的切换是有OS底层来进行控制的（例如时间中断）；而协程切换的时机以及切换的目标是有程序自身进行控制的。</p>
<p>由于多个协程运行与一个进程之中，<br>因此，不会存在同时写变量的冲突，不需要像多线程那样对共享资源进行加锁。</p>
<p>同时协程也没有多进程/多线程程序的切换开销，执行效率更高。</p>
<h2 id="Python对协程的支持"><a href="#Python对协程的支持" class="headerlink" title="Python对协程的支持"></a>Python对协程的支持</h2><p>由于协程的特点，要实现协程，很重要的一个方面就是context的保存和切换。</p>
<p>这一个特点跟用yield语句实现的生成器很像，只不过这个时候是在调用生成器的程序与生成器内部程序之间相互跳转交错执行。</p>
<p>实际上，python正是用yield语法来编写协程的。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432090171191d05dae6e129940518d1d6cf6eeaaa969000" target="_blank" rel="external">协程 - 廖雪峰的官方网站</a><br><a href="http://www.tuicool.com/articles/jeqMjq3" target="_blank" rel="external">从0到1，Python异步编程的演进之路</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前面的话&quot;&gt;&lt;a href=&quot;#前面的话&quot; class=&quot;headerlink&quot; title=&quot;前面的话&quot;&gt;&lt;/a&gt;前面的话&lt;/h2&gt;&lt;p&gt;这个星期在研究Scrapy media Pipeline源码 (&lt;a href=&quot;https://github.com/sc
    
    </summary>
    
      <category term="Python" scheme="https://resettingmq.github.io/categories/Python/"/>
    
    
      <category term="coroutine" scheme="https://resettingmq.github.io/tags/coroutine/"/>
    
      <category term="异步" scheme="https://resettingmq.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
</feed>
